Index: store/tweet.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package store\n\nimport (\n\t\"context\"\n\t\"github.com/arman-aminian/twitter-backend/model\"\n\t\"go.mongodb.org/mongo-driver/bson\"\n\t\"go.mongodb.org/mongo-driver/bson/primitive\"\n\t\"go.mongodb.org/mongo-driver/mongo\"\n\t\"regexp\"\n\t\"time\"\n)\n\ntype TweetStore struct {\n\tdb *mongo.Collection\n}\n\nfunc NewTweetStore(db *mongo.Collection) *TweetStore {\n\treturn &TweetStore{\n\t\tdb: db,\n\t}\n}\n\nfunc (ts *TweetStore) CreateTweet(t *model.Tweet) error {\n\t_, err := ts.db.InsertOne(context.TODO(), t)\n\treturn err\n}\n\nfunc (ts *TweetStore) RemoveTweet(t *model.Tweet) error {\n\t_, err := ts.db.DeleteOne(context.TODO(), t)\n\treturn err\n}\n\nfunc (ts *TweetStore) GetTweetById(id *string) (*model.Tweet, error) {\n\tvar t model.Tweet\n\toid, err := primitive.ObjectIDFromHex(*id)\n\tif err != nil {\n\t\treturn &t, nil\n\t}\n\terr = ts.db.FindOne(context.TODO(), bson.M{\"_id\": oid}).Decode(&t)\n\treturn &t, err\n}\n\nfunc (ts *TweetStore) GetAllTweets() ([]bson.M, error) {\n\tvar ret []bson.M\n\tcur, err := ts.db.Find(context.TODO(), bson.M{})\n\tif err = cur.All(context.TODO(), &ret); err != nil {\n\t\treturn nil, err\n\t}\n\treturn ret, nil\n}\n\nfunc (ts *TweetStore) AddCommentToTweet(parent *model.Tweet, child *model.CommentTweet) error {\n\t*parent.Comments = append(*parent.Comments, *child)\n\t_, err := ts.db.UpdateOne(context.TODO(), bson.M{\"_id\": parent.ID}, bson.M{\"$set\": bson.M{\"comments\": parent.Comments}})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (ts *TweetStore) LikeTweet(t *model.Tweet, u *model.User) error {\n\t*t.Likes = append(*t.Likes, *model.NewOwner(u.Username, u.ProfilePicture, u.Name, u.Bio))\n\t_, err := ts.db.UpdateOne(context.TODO(), bson.M{\"_id\": t.ID}, bson.M{\"$set\": bson.M{\"likes\": t.Likes}})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (ts *TweetStore) UnLikeTweet(t *model.Tweet, u *model.User) error {\n\tnewLikes := &[]model.Owner{}\n\tfor _, o := range *t.Likes {\n\t\tif o.Username != u.Username {\n\t\t\t*newLikes = append(*newLikes, o)\n\t\t}\n\t}\n\t_, err := ts.db.UpdateOne(context.TODO(), bson.M{\"_id\": t.ID}, bson.M{\"$set\": bson.M{\"likes\": newLikes}})\n\tif err != nil {\n\t\treturn err\n\t}\n\tt.Likes = newLikes\n\treturn nil\n}\n\nfunc (ts *TweetStore) Retweet(t *model.Tweet, u *model.User) error {\n\t*t.Retweets = append(*t.Retweets, *model.NewOwner(u.Username, u.ProfilePicture, u.Name, u.Bio))\n\t_, err := ts.db.UpdateOne(context.TODO(), bson.M{\"_id\": t.ID}, bson.M{\"$set\": bson.M{\"retweets\": t.Retweets}})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (ts *TweetStore) UnRetweet(t *model.Tweet, u *model.User) error {\n\tnewRetweets := &[]model.Owner{}\n\tfor _, o := range *t.Retweets {\n\t\tif o.Username != u.Username {\n\t\t\t*newRetweets = append(*newRetweets, o)\n\t\t}\n\t}\n\t_, err := ts.db.UpdateOne(context.TODO(), bson.M{\"_id\": t.ID}, bson.M{\"$set\": bson.M{\"retweets\": newRetweets}})\n\tif err != nil {\n\t\treturn err\n\t}\n\tt.Retweets = newRetweets\n\treturn nil\n}\n\nfunc (ts *TweetStore) ExtractHashtags(t *model.Tweet) map[string]int {\n\tmatchTags := regexp.MustCompile(`\\B[#]\\w*[a-zA-Z]+\\w*`)\n\tres := map[string]int{}\n\tfor _, v := range matchTags.FindAllString(t.Text, -1) {\n\t\tvn := v[1:]\n\t\tif _, ok := res[vn]; ok {\n\t\t\tres[vn] += 1\n\t\t} else {\n\t\t\tres[vn] = 1\n\t\t}\n\t}\n\treturn res\n}\n\nfunc (ts *TweetStore) GetTimelineFromTweetIDs(tweetsIDs []primitive.ObjectID, day int) (*[]model.Tweet, error) {\n\tdate := time.Now().AddDate(0, 0, day).Format(\"2006-01-02\")\n\tvar tweets []model.Tweet\n\tfilter := bson.M{\n\t\t\"$and\": []bson.M{\n\t\t\t{\"_id\": bson.M{\"$in\": tweetsIDs}},\n\t\t\t{\"date\": date},\n\t\t},\n\t}\n\n\tres, err := ts.db.Find(context.TODO(), filter)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err = res.All(context.TODO(), &tweets); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &tweets, err\n}\n\nfunc (ts *TweetStore) GetTweetSearchResult(query string) (*[]model.Tweet, error) {\n\tvar result []model.Tweet\n\tres, err := ts.db.Find(context.Background(), bson.M{\"$text\": bson.M{\"$search\": query}})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err = res.All(context.TODO(), &result); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &result, nil\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- store/tweet.go	(revision 3e30ce0bbc27a3bd580671e3e90c9f431f23c12f)
+++ store/tweet.go	(date 1611743652558)
@@ -7,7 +7,6 @@
 	"go.mongodb.org/mongo-driver/bson/primitive"
 	"go.mongodb.org/mongo-driver/mongo"
 	"regexp"
-	"time"
 )
 
 type TweetStore struct {
@@ -121,12 +120,12 @@
 }
 
 func (ts *TweetStore) GetTimelineFromTweetIDs(tweetsIDs []primitive.ObjectID, day int) (*[]model.Tweet, error) {
-	date := time.Now().AddDate(0, 0, day).Format("2006-01-02")
+	// date := time.Now().AddDate(0, 0, day).Format("2006-01-02")
 	var tweets []model.Tweet
 	filter := bson.M{
 		"$and": []bson.M{
 			{"_id": bson.M{"$in": tweetsIDs}},
-			{"date": date},
+			// {"date": date},
 		},
 	}
 
Index: handler/response.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package handler\n\nimport (\n\t\"github.com/arman-aminian/twitter-backend/model\"\n\t\"github.com/arman-aminian/twitter-backend/user\"\n\t\"github.com/arman-aminian/twitter-backend/utils\"\n\t\"github.com/labstack/echo/v4\"\n\t\"go.mongodb.org/mongo-driver/bson/primitive\"\n\t\"time\"\n)\n\ntype userResponse struct {\n\tUser struct {\n\t\tUsername       string `json:\"username\" bson:\"_id\"`\n\t\tEmail          string `json:\"email\"`\n\t\tName           string `json:\"name\"`\n\t\tBio            string `json:\"bio\"`\n\t\tProfilePicture string `json:\"profile_picture\"`\n\t\tToken          string `json:\"token\"`\n\t} `json:\"user\"`\n}\n\nfunc newUserResponse(u *model.User) *userResponse {\n\tr := new(userResponse)\n\tr.User.Username = u.Username\n\tr.User.Email = u.Email\n\tr.User.Name = u.Name\n\tr.User.Bio = u.Bio\n\tr.User.ProfilePicture = u.ProfilePicture\n\tr.User.Token = utils.GenerateJWT(u.Username)\n\treturn r\n}\n\ntype profileResponse struct {\n\tProfile struct {\n\t\tName           string                `json:\"name\"`\n\t\tIsFollowing    bool                  `json:\"is_following, omitempty\"`\n\t\tUsername       string                `json:\"username\" bson:\"_id\"`\n\t\tBio            string                `json:\"bio\"`\n\t\tProfilePicture string                `json:\"profile_picture\"`\n\t\tHeaderPicture  string                `json:\"header_picture\"`\n\t\tTweets         *[]primitive.ObjectID `json:\"tweets\"`\n\t\tFollowings     *[]model.Owner        `json:\"followings\"`\n\t\tFollowers      *[]model.Owner        `json:\"followers\"`\n\t} `json:\"profile\"`\n}\n\nfunc newProfileResponse(us user.Store, srcUsername string, u *model.User) *profileResponse {\n\tr := new(profileResponse)\n\tr.Profile.Name = u.Name\n\tr.Profile.Username = u.Username\n\tr.Profile.Bio = u.Bio\n\tr.Profile.ProfilePicture = u.ProfilePicture\n\tr.Profile.HeaderPicture = u.HeaderPicture\n\tr.Profile.Tweets = u.Tweets\n\tr.Profile.Followings = u.Followings\n\tr.Profile.Followers = u.Followers\n\tr.Profile.IsFollowing, _ = us.IsFollower(u.Username, srcUsername)\n\treturn r\n}\n\ntype FollowersAndFollowingListResponse struct {\n\tFollowers   *[]model.Owner `json:\"followers\" bson:\"followers\"`\n\tFollowings  *[]model.Owner `json:\"followings\" bson:\"followings\"`\n\tIsFollowing bool           `json:\"is_following, omitempty\"`\n}\n\nfunc newFollowingAndFollowersList(us user.Store, srcUsername string, u *model.User) *FollowersAndFollowingListResponse {\n\tl := new(FollowersAndFollowingListResponse)\n\tl.Followers = u.Followers\n\tl.Followings = u.Followings\n\tl.IsFollowing, _ = us.IsFollower(u.Username, srcUsername)\n\treturn l\n}\n\ntype OwnerListResponse struct {\n\tUsers *[]model.Owner `json:\"users\"`\n}\n\nfunc newOwnerList(users *[]model.Owner) *OwnerListResponse {\n\tl := new(OwnerListResponse)\n\tl.Users = users\n\treturn l\n}\n\ntype SingleEventResponse struct {\n\tMode      string      `json:\"mode\"`\n\tSource    model.Owner `json:\"source\"`\n\tTarget    model.Owner `json:\"target\"`\n\tContent   string      `json:\"content\"`\n\tTimeStamp time.Time   `json:\"timestamp\"`\n}\n\ntype EventListResponse struct {\n\tEvents []SingleEventResponse `json:\"events\"`\n}\n\nfunc newLogsList(u *model.User) *EventListResponse {\n\tret := new(EventListResponse)\n\tfor _, e := range *u.Logs {\n\t\tl := new(SingleEventResponse)\n\t\tl.Mode = e.Mode\n\t\tl.Source = e.Source\n\t\tl.Target = e.Target\n\t\tl.Content = e.Content\n\t\tl.TimeStamp = e.TimeStamp\n\t\tret.Events = append(ret.Events, *l)\n\t}\n\treturn ret\n}\n\nfunc newNotificationsList(u *model.User) *EventListResponse {\n\tret := new(EventListResponse)\n\tfor _, e := range *u.Notifications {\n\t\tl := new(SingleEventResponse)\n\t\tl.Mode = e.Mode\n\t\tl.Source = e.Source\n\t\tl.Target = e.Target\n\t\tl.Content = e.Content\n\t\tl.TimeStamp = e.TimeStamp\n\t\tret.Events = append(ret.Events, *l)\n\t}\n\treturn ret\n}\n\n//\t********************** Tweet Response **********************\n\ntype tweetResponse struct {\n\tID            string                `json:\"id\"`\n\tText          string                `json:\"text\"`\n\tMedia         string                `json:\"media\"`\n\tLiked         bool                  `json:\"liked\"`\n\tLikesCount    int                   `json:\"likes_count\"`\n\tRetweeted     bool                  `json:\"retweeted\"`\n\tRetweetsCount int                   `json:\"retweets_count\"`\n\tTime          time.Time             `json:\"time\" bson:\"time\"`\n\tOwner         model.Owner           `json:\"owner\"`\n\tParents       *[]model.CommentTweet `json:\"parents\" bson:\"parents\"`\n\tComments      *[]model.CommentTweet `json:\"comments\" bson:\"comments\"`\n}\n\ntype singleTweetResponse struct {\n\tTweet *tweetResponse `json:\"tweet\"`\n}\n\ntype tweetListResponse struct {\n\tTweets      []tweetResponse `json:\"tweets\"`\n\tTweetsCount int             `json:\"tweetsCount\"`\n}\n\nfunc newTweetResponse(c echo.Context, t *model.Tweet) *singleTweetResponse {\n\ttr := new(tweetResponse)\n\ttr.ID = t.ID.Hex()\n\ttr.Text = t.Text\n\ttr.Parents = t.Parents\n\ttr.Comments = t.Comments\n\ttr.Media = t.Media\n\ttr.Time = t.Time\n\tfor _, u := range *t.Likes {\n\t\tif u.Username == stringFieldFromToken(c, \"username\") {\n\t\t\ttr.Liked = true\n\t\t\tbreak\n\t\t}\n\t}\n\ttr.LikesCount = len(*t.Likes)\n\tfor _, u := range *t.Retweets {\n\t\tif u.Username == stringFieldFromToken(c, \"username\") {\n\t\t\ttr.Retweeted = true\n\t\t\tbreak\n\t\t}\n\t}\n\ttr.RetweetsCount = len(*t.Retweets)\n\ttr.Owner.Username = t.Owner.Username\n\ttr.Owner.ProfilePicture = t.Owner.ProfilePicture\n\n\treturn &singleTweetResponse{tr}\n}\n\nfunc newTweetListResponse(c echo.Context, username string, tweets *[]model.Tweet, size int) *tweetListResponse {\n\ttr := make([]tweetResponse, size)\n\tif tweets == nil {\n\t\treturn &tweetListResponse{tr, size}\n\t}\n\tfor i, tweet := range *tweets {\n\t\ttr[i].ID = tweet.ID.Hex()\n\t\ttr[i].Text = tweet.Text\n\t\ttr[i].Parents = tweet.Parents\n\t\ttr[i].Comments = tweet.Comments\n\t\ttr[i].Media = tweet.Media\n\t\ttr[i].Time = tweet.Time\n\n\t\tfor _, t := range *tweet.Likes {\n\t\t\tif t.Username == username {\n\t\t\t\ttr[i].Liked = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\ttr[i].LikesCount = len(*tweet.Likes)\n\t\tfor _, t := range *tweet.Retweets {\n\t\t\tif t.Username == username {\n\t\t\t\ttr[i].Retweeted = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\ttr[i].RetweetsCount = len(*tweet.Retweets)\n\t\ttr[i].Owner.Username = tweet.Owner.Username\n\t\ttr[i].Owner.ProfilePicture = tweet.Owner.ProfilePicture\n\t}\n\treturn &tweetListResponse{tr, size}\n}\n\ntype tweetLikeAndRetweetResponse struct {\n\tLikesList    *[]model.Owner `json:\"likes\" bson:\"likes\"`\n\tRetweetsList *[]model.Owner `json:\"retweets\" bson:\"retweets\"`\n}\n\nfunc newLikeAndRetweetResponse(t *model.Tweet) *tweetLikeAndRetweetResponse {\n\ttr := new(tweetLikeAndRetweetResponse)\n\ttr.LikesList = t.Likes\n\ttr.RetweetsList = t.Retweets\n\treturn tr\n}\n\ntype timelineResponse struct {\n\ttimeline *[]model.Tweet\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- handler/response.go	(revision 3e30ce0bbc27a3bd580671e3e90c9f431f23c12f)
+++ handler/response.go	(date 1611742665619)
@@ -5,7 +5,6 @@
 	"github.com/arman-aminian/twitter-backend/user"
 	"github.com/arman-aminian/twitter-backend/utils"
 	"github.com/labstack/echo/v4"
-	"go.mongodb.org/mongo-driver/bson/primitive"
 	"time"
 )
 
@@ -33,26 +32,26 @@
 
 type profileResponse struct {
 	Profile struct {
-		Name           string                `json:"name"`
-		IsFollowing    bool                  `json:"is_following, omitempty"`
-		Username       string                `json:"username" bson:"_id"`
-		Bio            string                `json:"bio"`
-		ProfilePicture string                `json:"profile_picture"`
-		HeaderPicture  string                `json:"header_picture"`
-		Tweets         *[]primitive.ObjectID `json:"tweets"`
-		Followings     *[]model.Owner        `json:"followings"`
-		Followers      *[]model.Owner        `json:"followers"`
+		Name           string `json:"name"`
+		IsFollowing    bool   `json:"is_following, omitempty"`
+		Username       string `json:"username" bson:"_id"`
+		Bio            string `json:"bio"`
+		ProfilePicture string `json:"profile_picture"`
+		HeaderPicture  string `json:"header_picture"`
+		Tweets         *tweetListResponse
+		Followings     *[]model.Owner `json:"followings"`
+		Followers      *[]model.Owner `json:"followers"`
 	} `json:"profile"`
 }
 
-func newProfileResponse(us user.Store, srcUsername string, u *model.User) *profileResponse {
+func newProfileResponse(us user.Store, srcUsername string, u *model.User, tweetList *tweetListResponse) *profileResponse {
 	r := new(profileResponse)
 	r.Profile.Name = u.Name
 	r.Profile.Username = u.Username
 	r.Profile.Bio = u.Bio
 	r.Profile.ProfilePicture = u.ProfilePicture
 	r.Profile.HeaderPicture = u.HeaderPicture
-	r.Profile.Tweets = u.Tweets
+	r.Profile.Tweets = tweetList
 	r.Profile.Followings = u.Followings
 	r.Profile.Followers = u.Followers
 	r.Profile.IsFollowing, _ = us.IsFollower(u.Username, srcUsername)
@@ -172,7 +171,9 @@
 	tr.RetweetsCount = len(*t.Retweets)
 	tr.Owner.Username = t.Owner.Username
 	tr.Owner.ProfilePicture = t.Owner.ProfilePicture
-
+	tr.Owner.Bio = t.Owner.Bio
+	tr.Owner.Name = t.Owner.Name
+	
 	return &singleTweetResponse{tr}
 }
 
@@ -188,7 +189,7 @@
 		tr[i].Comments = tweet.Comments
 		tr[i].Media = tweet.Media
 		tr[i].Time = tweet.Time
-
+		
 		for _, t := range *tweet.Likes {
 			if t.Username == username {
 				tr[i].Liked = true
@@ -205,6 +206,8 @@
 		tr[i].RetweetsCount = len(*tweet.Retweets)
 		tr[i].Owner.Username = tweet.Owner.Username
 		tr[i].Owner.ProfilePicture = tweet.Owner.ProfilePicture
+		tr[i].Owner.Bio = tweet.Owner.Bio
+		tr[i].Owner.Name = tweet.Owner.Name
 	}
 	return &tweetListResponse{tr, size}
 }
Index: handler/tweet.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package handler\n\nimport (\n\t\"errors\"\n\t\"github.com/arman-aminian/twitter-backend/model\"\n\t\"github.com/arman-aminian/twitter-backend/utils\"\n\t\"github.com/labstack/echo/v4\"\n\t\"go.mongodb.org/mongo-driver/bson/primitive\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\n// CreateArticle godoc\n// @Summary Create an tweet\n// @Description Create an tweet\n// @ID create-tweet\n// @Tags article\n// @Accept  json\n// @Produce  json\n// @Param article body tweetCreateRequest true \"Article to create\"\n// @Success 201 {object} singleTweetResponse\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /articles [post]\nfunc (h *Handler) CreateTweet(c echo.Context) error {\n\tt := model.NewTweet()\n\n\tt.ID = primitive.NewObjectID()\n\tt.Text = c.FormValue(\"text\")\n\n\tfile, err := c.FormFile(\"media\")\n\tif err == nil {\n\t\tsrc, err := file.Open()\n\t\tif err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tdefer src.Close()\n\n\t\tmediaFolderName := \"media/tweet-assets/\"\n\t\tmediaPath := mediaFolderName + file.Filename\n\t\tdst, err := os.Create(mediaPath)\n\t\tif err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tdefer dst.Close()\n\n\t\tif _, err = io.Copy(dst, src); err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tt.Media = mediaPath\n\t} else {\n\t\t// Tweet without media\n\t\tt.Media = \"\"\n\t}\n\n\tu, _ := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tt.Owner.Username = u.Username\n\tt.Owner.ProfilePicture = u.ProfilePicture\n\tt.Time = time.Now()\n\tt.Date = time.Now().Format(\"2006-01-02\")\n\n\tparentId := c.FormValue(\"parent\")\n\tif parentId != \"\" {\n\t\tp, err := h.tweetStore.GetTweetById(&parentId)\n\t\tif err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tif p == nil {\n\t\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t\t}\n\n\t\tpid, _ := h.tweetStore.GetTweetById(&parentId)\n\t\t*t.Parents = append(*p.Parents, *model.NewCommentTweet(*pid))\n\t\terr = h.tweetStore.AddCommentToTweet(p, model.NewCommentTweet(*t))\n\t\tif err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t}\n\n\terr = h.tweetStore.CreateTweet(t)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\n\terr = h.userStore.AddTweet(u, t)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\n\thashtags := h.tweetStore.ExtractHashtags(t)\n\tfor name, cnt := range hashtags {\n\t\th.AddHashtag(name, t, cnt)\n\t}\n\n\tres := newTweetResponse(c, t)\n\treturn c.JSON(http.StatusCreated, res)\n}\n\nfunc (h *Handler) GetTweetAssetFile(c echo.Context) error {\n\tmediaFolderName := \"media/tweet-assets/\"\n\tmediaPath := mediaFolderName + c.Param(\"filename\")\n\treturn c.File(mediaPath)\n}\n\nfunc (h *Handler) GetTweet(c echo.Context) error {\n\tid := c.Param(\"id\")\n\tt, err := h.tweetStore.GetTweetById(&id)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif t == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\n\treturn c.JSON(http.StatusOK, newTweetResponse(c, t))\n}\n\nfunc (h *Handler) DeleteTweet(c echo.Context) error {\n\tid := c.Param(\"id\")\n\tt, err := h.tweetStore.GetTweetById(&id)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif t == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\n\tu, err := h.userStore.GetByUsername(t.Owner.Username)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tif u.Username != t.Owner.Username {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"you can only delete you tweets\")))\n\t}\n\n\terr = h.userStore.RemoveTweet(u, &id)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\n\terr = h.tweetStore.RemoveTweet(t)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\n\thashtags := h.tweetStore.ExtractHashtags(t)\n\th.hashtagStore.DeleteTweetHashtags(t, hashtags)\n\n\treturn c.JSON(http.StatusOK, newTweetResponse(c, t))\n}\n\n// GetArticle godoc\n// @Summary Get an article\n// @Description Get an article. Auth not required\n// @ID get-article\n// @Tags article\n// @Accept  json\n// @Produce  json\n// @Param slug path string true \"Slug of the article to get\"\n// @Success 200 {object} singleArticleResponse\n// @Failure 400 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Router /articles/{slug} [get]\nfunc (h *Handler) GetTweetLikeAndRetweetList(c echo.Context) error {\n\tid := c.Param(\"id\")\n\tt, err := h.tweetStore.GetTweetById(&id)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif t == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\n\treturn c.JSON(http.StatusOK, newLikeAndRetweetResponse(t))\n}\n\n// GetArticle godoc\n// @Summary Get an article\n// @Description Get an article. Auth not required\n// @ID get-article\n// @Tags article\n// @Accept  json\n// @Produce  json\n// @Param slug path string true \"Slug of the article to get\"\n// @Success 200 {object} singleArticleResponse\n// @Failure 400 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Router /articles/{slug} [get]\nfunc (h *Handler) GetRetweetList(c echo.Context) error {\n\tid := c.Param(\"id\")\n\tt, err := h.tweetStore.GetTweetById(&id)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif t == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\n\treturn c.JSON(http.StatusOK, newLikeAndRetweetResponse(t))\n}\n\n// Favorite godoc\n// @Summary Favorite an article\n// @Description Favorite an article. Auth is required\n// @ID favorite\n// @Tags favorite\n// @Accept  json\n// @Produce  json\n// @Param slug path string true \"Slug of the article that you want to favorite\"\n// @Success 200 {object} singleArticleResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /articles/{slug}/favorite [post]\nfunc (h *Handler) Like(c echo.Context) error {\n\tid := c.Param(\"id\")\n\tt, err := h.tweetStore.GetTweetById(&id)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif t == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tu, err := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tfor _, o := range *t.Likes {\n\t\tif u.Username == o.Username {\n\t\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"already liked\")))\n\t\t}\n\t}\n\n\tif err := h.tweetStore.LikeTweet(t, u); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\n\te := h.CreateLikeEvent(u, t)\n\terr = h.userStore.AddLog(u, e)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\ttarget, err := h.userStore.GetByUsername(t.Owner.Username)\n\tif target == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\terr = h.userStore.AddNotification(target, e)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\n\treturn c.JSON(http.StatusOK, newTweetResponse(c, t))\n}\n\n// Favorite godoc\n// @Summary Favorite an article\n// @Description Favorite an article. Auth is required\n// @ID favorite\n// @Tags favorite\n// @Accept  json\n// @Produce  json\n// @Param slug path string true \"Slug of the article that you want to favorite\"\n// @Success 200 {object} singleArticleResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /articles/{slug}/favorite [post]\nfunc (h *Handler) UnLike(c echo.Context) error {\n\tid := c.Param(\"id\")\n\tt, err := h.tweetStore.GetTweetById(&id)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif t == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tu, err := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tb := false\n\tfor _, o := range *t.Likes {\n\t\tif u.Username == o.Username {\n\t\t\tb = true\n\t\t}\n\t}\n\tif !b {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"hasn't liked\")))\n\t}\n\n\tif err := h.tweetStore.UnLikeTweet(t, u); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\n\treturn c.JSON(http.StatusOK, newTweetResponse(c, t))\n}\n\n// Favorite godoc\n// @Summary Favorite an article\n// @Description Favorite an article. Auth is required\n// @ID favorite\n// @Tags favorite\n// @Accept  json\n// @Produce  json\n// @Param slug path string true \"Slug of the article that you want to favorite\"\n// @Success 200 {object} singleArticleResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /articles/{slug}/favorite [post]\nfunc (h *Handler) Retweet(c echo.Context) error {\n\tid := c.Param(\"id\")\n\tt, err := h.tweetStore.GetTweetById(&id)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif t == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tu, err := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tfor _, o := range *t.Retweets {\n\t\tif u.Username == o.Username {\n\t\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"already retweeted\")))\n\t\t}\n\t}\n\n\tif err := h.tweetStore.Retweet(t, u); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\n\terr = h.userStore.AddTweet(u, t)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\n\te := h.CreateRetweetEvent(u, t)\n\terr = h.userStore.AddLog(u, e)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\ttarget, err := h.userStore.GetByUsername(t.Owner.Username)\n\tif target == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\terr = h.userStore.AddNotification(target, e)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\n\treturn c.JSON(http.StatusOK, newTweetResponse(c, t))\n}\n\n// Favorite godoc\n// @Summary Favorite an article\n// @Description Favorite an article. Auth is required\n// @ID favorite\n// @Tags favorite\n// @Accept  json\n// @Produce  json\n// @Param slug path string true \"Slug of the article that you want to favorite\"\n// @Success 200 {object} singleArticleResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /articles/{slug}/favorite [post]\nfunc (h *Handler) UnRetweet(c echo.Context) error {\n\tid := c.Param(\"id\")\n\tt, err := h.tweetStore.GetTweetById(&id)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif t == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tu, err := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tb := false\n\tfor _, o := range *t.Retweets {\n\t\tif u.Username == o.Username {\n\t\t\tb = true\n\t\t}\n\t}\n\tif !b {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"hasn't retweeted\")))\n\t}\n\n\tif err := h.tweetStore.UnRetweet(t, u); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\n\terr = h.userStore.RemoveTweet(u, &id)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\n\treturn c.JSON(http.StatusOK, newTweetResponse(c, t))\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- handler/tweet.go	(revision 3e30ce0bbc27a3bd580671e3e90c9f431f23c12f)
+++ handler/tweet.go	(date 1611742666063)
@@ -60,6 +60,8 @@
 	u, _ := h.userStore.GetByUsername(stringFieldFromToken(c, "username"))
 	t.Owner.Username = u.Username
 	t.Owner.ProfilePicture = u.ProfilePicture
+	t.Owner.Name = u.Name
+	t.Owner.Bio = u.Bio
 	t.Time = time.Now()
 	t.Date = time.Now().Format("2006-01-02")
 
Index: handler/user.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package handler\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/arman-aminian/twitter-backend/model\"\n\t\"github.com/arman-aminian/twitter-backend/utils\"\n\t\"github.com/jinzhu/copier\"\n\t\"github.com/labstack/echo/v4\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"sort\"\n\t\"strconv\"\n\t\"time\"\n)\n\n// signUp godoc\n// @Summary Register a new user\n// @Description Register a new user\n// @ID sign-up\n// @Tags user\n// @Accept  json\n// @Produce  json\n// @Param user body userRegisterRequest true \"User info for registration\"\n// @Success 201 {object} userResponse\n// @Failure 400 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Router /users [post]\nfunc (h *Handler) SignUp(c echo.Context) error {\n\tu := model.NewUser()\n\treq := &userRegisterRequest{}\n\tif err := req.bind(c, u); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\tif err := h.userStore.Create(u); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\tresponse := newUserResponse(u)\n\tcookie := new(http.Cookie)\n\tcookie.Name = \"Token\"\n\tcookie.Value = response.User.Token\n\tcookie.Expires = time.Now().Add(24 * time.Hour)\n\tc.SetCookie(cookie)\n\t//header('Access-Control-Allow-Origin', yourExactHostname);\n\n\t//c.Response().Header().Set(echo.HeaderAccessControlAllowOrigin, \"http://localhost:3000\")\n\t//c.Response().Header().Add(echo.HeaderAccessControlAllowCredentials, \"true\")\n\t//c.Response().Header().Add(echo.HeaderAccessControlAllowOrigin, \"http://localhost:3000\")\n\t//c.Response().Header().Add(echo.HeaderAccessControlAllowHeaders, \"Origin, X-Requested-With, Content-Type, Accept\")\n\t//c.Response().Header().\n\treturn c.JSON(http.StatusCreated, response)\n}\n\n// Login godoc\n// @Summary Login for existing user\n// @Description Login for existing user\n// @ID login\n// @Tags user\n// @Accept  json\n// @Produce  json\n// @Param user body userLoginRequest true \"Credentials to use\"\n// @Success 200 {object} userResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Router /users/login [post]\nfunc (h *Handler) Login(c echo.Context) error {\n\treq := &userLoginRequest{}\n\tif err := req.bind(c); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\tu, err := h.userStore.GetByEmail(req.User.Email)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusForbidden, utils.AccessForbidden())\n\t}\n\tif !u.CheckPassword(req.User.Password) {\n\t\treturn c.JSON(http.StatusForbidden, utils.AccessForbidden())\n\t}\n\tresponse := newUserResponse(u)\n\t//cookie := new(http.Cookie)\n\t//cookie.Name = \"Token\"\n\t//cookie.Value = response.User.Token\n\t//cookie.Expires = time.Now().Add(24 * time.Hour)\n\t//c.SetCookie(cookie)\n\treturn c.JSON(http.StatusCreated, response)\n}\n\n// UpdateUser godoc\n// @Summary Update current user\n// @Description Update user information for current user\n// @ID update-user\n// @Tags user\n// @Accept  json\n// @Produce  json\n// @Param user body userUpdateRequest true \"User details to update. At least **one** field is required.\"\n// @Success 200 {object} userResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /user [put]\nfunc (h *Handler) UpdateUser(c echo.Context) error {\n\toldUser, err := h.userStore.GetByUsername(c.Param(\"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif oldUser == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tnewUser := model.NewUser()\n\t_ = copier.Copy(&newUser, &oldUser)\n\treq := newUserUpdateRequest()\n\treq.populate(newUser)\n\tif err := req.bind(c, newUser); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\tif err := h.userStore.Update(oldUser, newUser); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\treturn c.JSON(http.StatusOK, newUserResponse(newUser))\n}\n\n// GetProfile godoc\n// @Summary Get a profile\n// @Description Get a profile of a user of the system. Auth is optional\n// @ID get-profile\n// @Tags profile\n// @Accept  json\n// @Produce  json\n// @Param username path string true \"Username of the profile to get\"\n// @Success 200 {object} userResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /profiles/{username} [get]\nfunc (h *Handler) GetProfile(c echo.Context) error {\n\tdestUsername := c.Param(\"username\")\n\tfmt.Println(destUsername)\n\tu, err := h.userStore.GetByUsername(destUsername)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\treturn c.JSON(http.StatusOK, newProfileResponse(h.userStore, stringFieldFromToken(c, \"username\"), u))\n}\n\n// UpdateProfile godoc\n// @Summary Update a user's profile\n// @Description Update user profile\n// @ID update-profile\n// @Tags user\n// @Accept  json\n// @Produce  json\n// @Param user body userProfileUpdateRequest true \"User details to update. At least **one** field is required.\"\n// @Success 200 {object} userResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /user [put]\nfunc (h *Handler) UpdateProfile(c echo.Context) error {\n\tu, err := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\treq := newUserProfileUpdateRequest()\n\treq.populate(u)\n\tu.Name = c.FormValue(\"name\")\n\tu.Bio = c.FormValue(\"bio\")\n\tppf, err := c.FormFile(\"profile_picture\")\n\tif err == nil {\n\t\tsrc, err := ppf.Open()\n\t\tif err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tdefer src.Close()\n\n\t\tmediaFolderName := \"media/profile-pictures/\"\n\t\tmediaPath := mediaFolderName + ppf.Filename\n\t\tdst, err := os.Create(mediaPath)\n\t\tif err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tdefer dst.Close()\n\n\t\tif _, err = io.Copy(dst, src); err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tu.ProfilePicture = mediaPath\n\t} else {\n\t\t// Update without Profile Picture\n\t\tu.ProfilePicture = \"\"\n\t}\n\n\thpf, err := c.FormFile(\"header_picture\")\n\tif err == nil {\n\t\tsrc, err := hpf.Open()\n\t\tif err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tdefer src.Close()\n\n\t\tmediaFolderName := \"media/header-pictures/\"\n\t\tmediaPath := mediaFolderName + hpf.Filename\n\t\tdst, err := os.Create(mediaPath)\n\t\tif err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tdefer dst.Close()\n\n\t\tif _, err = io.Copy(dst, src); err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tu.HeaderPicture = mediaPath\n\t} else {\n\t\t// Update without Header Picture\n\t\tu.HeaderPicture = \"\"\n\t}\n\n\tif err := h.userStore.UpdateProfile(u); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\treturn c.JSON(http.StatusOK, newProfileResponse(h.userStore, u.Username, u))\n}\n\nfunc (h *Handler) GetProfilePictureFile(c echo.Context) error {\n\tmediaFolderName := \"media/profile-pictures/\"\n\tmediaPath := mediaFolderName + c.Param(\"filename\")\n\treturn c.File(mediaPath)\n}\n\nfunc (h *Handler) GetHeaderPictureFile(c echo.Context) error {\n\tmediaFolderName := \"media/header-pictures/\"\n\tmediaPath := mediaFolderName + c.Param(\"filename\")\n\treturn c.File(mediaPath)\n}\n\n// Follow godoc\n// @Summary Follow a user\n// @Description Follow a user by username\n// @ID follow\n// @Tags follow\n// @Accept  json\n// @Produce  json\n// @Param username path string true \"Username of the profile you want to follow\"\n// @Success 200 {object} profileResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /profiles/{username}/follow [post]\nfunc (h *Handler) Follow(c echo.Context) error {\n\tfollower, err := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tu, err := h.userStore.GetByUsername(c.Param(\"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tif u.Username == follower.Username {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"can't follow yourself\")))\n\t}\n\tif Contains(*u.Followers, follower.Username) || Contains(*follower.Followings, u.Username) {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"already follows the target\")))\n\t}\n\n\tif err := h.userStore.AddFollower(u, follower); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\n\te := h.CreateFollowEvent(follower, u)\n\terr = h.userStore.AddLog(follower, e)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\terr = h.userStore.AddNotification(u, e)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\n\treturn c.JSON(http.StatusOK, newProfileResponse(h.userStore, follower.Username, u))\n}\n\n// Unfollow godoc\n// @Summary Unfollow a user\n// @Description Unfollow a user by username\n// @ID unfollow\n// @Tags follow\n// @Accept  json\n// @Produce  json\n// @Param username path string true \"Username of the profile you want to unfollow\"\n// @Success 201 {object} userResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /profiles/{username}/follow [delete]\nfunc (h *Handler) UnFollow(c echo.Context) error {\n\tfollower, err := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tu, err := h.userStore.GetByUsername(c.Param(\"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tif u.Username == follower.Username {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"can't unfollow yourself\")))\n\t}\n\tif !Contains(*u.Followers, follower.Username) || !Contains(*follower.Followings, u.Username) {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"doesn't follow the target\")))\n\t}\n\tif err := h.userStore.RemoveFollower(u, follower); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\treturn c.JSON(http.StatusOK, newProfileResponse(h.userStore, stringFieldFromToken(c, \"username\"), u))\n}\n\n// Articles godoc\n// @Summary Get recent articles globally\n// @Description Get most recent articles globally. Use query parameters to filter results. Auth is optional\n// @ID get-articles\n// @Tags article\n// @Accept  json\n// @Produce  json\n// @Param tag query string false \"Filter by tag\"\n// @Param author query string false \"Filter by author (username)\"\n// @Param favorited query string false \"Filter by favorites of a user (username)\"\n// @Param limit query integer false \"Limit number of articles returned (default is 20)\"\n// @Param offset query integer false \"Offset/skip number of articles (default is 0)\"\n// @Success 200 {object} articleListResponse\n// @Failure 500 {object} utils.Error\n// @Router /articles [get]\nfunc (h *Handler) GetTimeline(c echo.Context) error {\n\tday, err := strconv.Atoi(c.Param(\"day\"))\n\tif err != nil {\n\t\tday = 0\n\t}\n\tday = -1 * day\n\tu, err := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\n\tvar usernames []string\n\tfor _, f := range *u.Followings {\n\t\tusernames = append(usernames, f.Username)\n\t}\n\tusernames = append(usernames, u.Username)\n\tif len(usernames) == 0 {\n\t\treturn c.JSON(http.StatusOK, newTweetListResponse(c, stringFieldFromToken(c, \"username\"), nil, 0))\n\t}\n\n\ttweetsId, err := h.userStore.GetTweetIdListFromUsernameList(usernames)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\tif len(*tweetsId) == 0 {\n\t\treturn c.JSON(http.StatusOK, newTweetListResponse(c, stringFieldFromToken(c, \"username\"), nil, 0))\n\t}\n\n\ttimelineTweets, err := h.tweetStore.GetTimelineFromTweetIDs(*tweetsId, day)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\n\t// sort timeline by tweet's creating time\n\ttimeline := *timelineTweets\n\tsort.Slice(timeline, func(i, j int) bool {\n\t\treturn timeline[i].Time.After(timeline[j].Time)\n\t})\n\tfmt.Println(timeline[0])\n\treturn c.JSON(http.StatusOK, newTweetListResponse(c, stringFieldFromToken(c, \"username\"), &timeline, len(timeline)))\n}\n\nfunc (h *Handler) SearchUsernames(c echo.Context) error {\n\tquery := c.QueryParam(\"query\")\n\tif query == \"\" {\n\t\treturn c.JSON(http.StatusBadRequest, utils.NewError(errors.New(\"nothing to search for\")))\n\t}\n\n\tresult, err := h.userStore.GetUsernameSearchResult(query)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn c.JSON(http.StatusOK, newOwnerList(result))\n}\n\nfunc (h *Handler) SearchTweets(c echo.Context) error {\n\tquery := &model.SearchQuery{}\n\terr := c.Bind(query)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\tif query.Query == \"\" {\n\t\treturn c.JSON(http.StatusBadRequest, utils.NewError(errors.New(\"nothing to search for\")))\n\t}\n\tresult, err := h.tweetStore.GetTweetSearchResult(query.Query)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\treturn c.JSON(http.StatusOK, newTweetListResponse(c, stringFieldFromToken(c, \"username\"), result, len(*result)))\n}\n\nfunc (h *Handler) GetFollowingAndFollowersList(c echo.Context) error {\n\tu, err := h.userStore.GetByUsername(c.Param(\"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\treturn c.JSON(http.StatusOK, newFollowingAndFollowersList(h.userStore, stringFieldFromToken(c, \"username\"), u))\n}\n\nfunc (h *Handler) GetLogs(c echo.Context) error {\n\tu, err := h.userStore.GetByUsername(c.Param(\"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\treturn c.JSON(http.StatusOK, newLogsList(u))\n}\n\nfunc (h *Handler) GetNotifications(c echo.Context) error {\n\tu, err := h.userStore.GetByUsername(c.Param(\"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\treturn c.JSON(http.StatusOK, newNotificationsList(u))\n}\n\nfunc (h *Handler) GetSuggestions(c echo.Context) error {\n\tprintln(\"suggestions\")\n\tusername := stringFieldFromToken(c, \"username\")\n\tu, err := h.userStore.GetByUsername(username)\n\tfmt.Println(u)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tif len(*u.Followings) == 0 {\n\t\treturn c.JSON(http.StatusOK, newOwnerList(nil))\n\t}\n\tvar suggestions []model.Owner\n\tfor _, f := range *u.Followings {\n\t\tfollowing, _ := h.userStore.GetByUsername(f.Username)\n\t\tsuggestions = append(suggestions, *following.Followings...)\n\t}\n\n\t// to sort suggestions by their frequencies\n\tsuggestionsFreq := dupCount(suggestions)\n\tfmt.Println(suggestionsFreq)\n\tsorted := make([]model.Owner, 0, len(suggestionsFreq))\n\tfor name := range suggestionsFreq {\n\t\tsorted = append(sorted, name)\n\t}\n\tsort.Slice(sorted, func(i, j int) bool {\n\t\treturn suggestionsFreq[sorted[i]] > suggestionsFreq[sorted[j]]\n\t})\n\n\tmaxNumberOfSuggestions := 3\n\tif len(sorted) < maxNumberOfSuggestions {\n\t\treturn c.JSON(http.StatusOK, newOwnerList(&sorted))\n\t}\n\tsorted = sorted[:maxNumberOfSuggestions]\n\treturn c.JSON(http.StatusOK, newOwnerList(&sorted))\n}\n\nfunc dupCount(list []model.Owner) map[model.Owner]int {\n\tduplicateFrequency := make(map[model.Owner]int)\n\tfor _, item := range list {\n\t\t_, exist := duplicateFrequency[item]\n\t\tif exist {\n\t\t\tduplicateFrequency[item] += 1 // increase counter by 1 if already in the map\n\t\t} else {\n\t\t\tduplicateFrequency[item] = 1 // else start counting from 1\n\t\t}\n\t}\n\treturn duplicateFrequency\n}\n\nfunc getFollowingUsernames(followings []model.Owner) []string {\n\tvar res []string\n\tfor _, f := range followings {\n\t\tres = append(res, f.Username)\n\t}\n\treturn res\n}\n\nfunc stringFieldFromToken(c echo.Context, field string) string {\n\tfield, ok := c.Get(field).(string)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn field\n}\n\nfunc Contains(slice []model.Owner, val string) bool {\n\tfor _, item := range slice {\n\t\tif item.Username == val {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- handler/user.go	(revision 3e30ce0bbc27a3bd580671e3e90c9f431f23c12f)
+++ handler/user.go	(date 1611744867838)
@@ -155,7 +155,13 @@
 	if u == nil {
 		return c.JSON(http.StatusNotFound, utils.NotFound())
 	}
-	return c.JSON(http.StatusOK, newProfileResponse(h.userStore, stringFieldFromToken(c, "username"), u))
+	tweets, err := h.tweetStore.GetTimelineFromTweetIDs(*u.Tweets, -7)
+	if err != nil {
+		return c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))
+	}
+	sorted := sortTweets(tweets)
+	lst := newTweetListResponse(c, stringFieldFromToken(c, "username"), sorted, len(*sorted))
+	return c.JSON(http.StatusOK, newProfileResponse(h.userStore, stringFieldFromToken(c, "username"), u, lst))
 }
 
 // UpdateProfile godoc
@@ -239,7 +245,14 @@
 	if err := h.userStore.UpdateProfile(u); err != nil {
 		return c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))
 	}
-	return c.JSON(http.StatusOK, newProfileResponse(h.userStore, u.Username, u))
+	
+	tweets, err := h.tweetStore.GetTimelineFromTweetIDs(*u.Tweets, -7)
+	if err != nil {
+		return c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))
+	}
+	sorted := sortTweets(tweets)
+	lst := newTweetListResponse(c, stringFieldFromToken(c, "username"), sorted, len(*sorted))
+	return c.JSON(http.StatusOK, newProfileResponse(h.userStore, u.Username, u, lst))
 }
 
 func (h *Handler) GetProfilePictureFile(c echo.Context) error {
@@ -302,8 +315,14 @@
 	if err != nil {
 		return c.JSON(http.StatusInternalServerError, utils.NewError(err))
 	}
-
-	return c.JSON(http.StatusOK, newProfileResponse(h.userStore, follower.Username, u))
+	
+	tweets, err := h.tweetStore.GetTimelineFromTweetIDs(*u.Tweets, -7)
+	if err != nil {
+		return c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))
+	}
+	sorted := sortTweets(tweets)
+	lst := newTweetListResponse(c, stringFieldFromToken(c, "username"), sorted, len(*sorted))
+	return c.JSON(http.StatusOK, newProfileResponse(h.userStore, follower.Username, u, lst))
 }
 
 // Unfollow godoc
@@ -343,7 +362,14 @@
 	if err := h.userStore.RemoveFollower(u, follower); err != nil {
 		return c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))
 	}
-	return c.JSON(http.StatusOK, newProfileResponse(h.userStore, stringFieldFromToken(c, "username"), u))
+	
+	tweets, err := h.tweetStore.GetTimelineFromTweetIDs(*u.Tweets, -7)
+	if err != nil {
+		return c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))
+	}
+	sorted := sortTweets(tweets)
+	lst := newTweetListResponse(c, stringFieldFromToken(c, "username"), sorted, len(*sorted))
+	return c.JSON(http.StatusOK, newProfileResponse(h.userStore, stringFieldFromToken(c, "username"), u, lst))
 }
 
 // Articles godoc
@@ -395,12 +421,8 @@
 	}
 
 	// sort timeline by tweet's creating time
-	timeline := *timelineTweets
-	sort.Slice(timeline, func(i, j int) bool {
-		return timeline[i].Time.After(timeline[j].Time)
-	})
-	fmt.Println(timeline[0])
-	return c.JSON(http.StatusOK, newTweetListResponse(c, stringFieldFromToken(c, "username"), &timeline, len(timeline)))
+	timeline := sortTweets(timelineTweets)
+	return c.JSON(http.StatusOK, newTweetListResponse(c, stringFieldFromToken(c, "username"), timeline, len(*timeline)))
 }
 
 func (h *Handler) SearchUsernames(c echo.Context) error {
@@ -429,7 +451,8 @@
 	if err != nil {
 		return c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))
 	}
-	return c.JSON(http.StatusOK, newTweetListResponse(c, stringFieldFromToken(c, "username"), result, len(*result)))
+	sorted := sortTweets(result)
+	return c.JSON(http.StatusOK, newTweetListResponse(c, stringFieldFromToken(c, "username"), sorted, len(*sorted)))
 }
 
 func (h *Handler) GetFollowingAndFollowersList(c echo.Context) error {
@@ -504,6 +527,14 @@
 	return c.JSON(http.StatusOK, newOwnerList(&sorted))
 }
 
+func sortTweets(tweets *[]model.Tweet) *[]model.Tweet {
+	sorted := *tweets
+	sort.Slice(sorted, func(i, j int) bool {
+		return sorted[i].Time.After(sorted[j].Time)
+	})
+	return &sorted
+}
+
 func dupCount(list []model.Owner) map[model.Owner]int {
 	duplicateFrequency := make(map[model.Owner]int)
 	for _, item := range list {
Index: tweet/tweet.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package tweet\n\nimport (\n\t\"github.com/arman-aminian/twitter-backend/model\"\n\t\"go.mongodb.org/mongo-driver/bson\"\n\t\"go.mongodb.org/mongo-driver/bson/primitive\"\n)\n\ntype Store interface {\n\tCreateTweet(*model.Tweet) error\n\tAddCommentToTweet(parent *model.Tweet, child *model.CommentTweet) error\n\tRemoveTweet(*model.Tweet) error\n\tGetTweetById(id *string) (*model.Tweet, error)\n\tGetAllTweets() ([]bson.M, error)\n\tLikeTweet(t *model.Tweet, u *model.User) error\n\tUnLikeTweet(t *model.Tweet, u *model.User) error\n\tRetweet(t *model.Tweet, u *model.User) error\n\tUnRetweet(t *model.Tweet, u *model.User) error\n\n\tExtractHashtags(t *model.Tweet) map[string]int\n\n\tGetTimelineFromTweetIDs(usernames []primitive.ObjectID, day int) (*[]model.Tweet, error)\n\tGetTweetSearchResult(username string) (*[]model.Tweet, error)\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- tweet/tweet.go	(revision 3e30ce0bbc27a3bd580671e3e90c9f431f23c12f)
+++ tweet/tweet.go	(date 1611742905943)
@@ -19,6 +19,6 @@
 
 	ExtractHashtags(t *model.Tweet) map[string]int
 
-	GetTimelineFromTweetIDs(usernames []primitive.ObjectID, day int) (*[]model.Tweet, error)
+	GetTimelineFromTweetIDs(tweetIDs []primitive.ObjectID, day int) (*[]model.Tweet, error)
 	GetTweetSearchResult(username string) (*[]model.Tweet, error)
 }
Index: model/user.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package model\n\nimport (\n\t\"errors\"\n\t\"go.mongodb.org/mongo-driver/bson/primitive\"\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\ntype User struct {\n\tName     string `json:\"name\" bson:\"name\"`\n\tUsername string `json:\"username\" bson:\"_id\"`\n\tEmail    string `json:\"email\" bson:\"email\"`\n\tPassword string `json:\"password\" bson:\"password\"`\n\n\t// Fluff shown to user as profile\n\tBio            string `json:\"bio\" bson:\"bio\"`\n\tProfilePicture string `json:\"profile_picture\" bson:\"profile_picture\"`\n\tHeaderPicture  string `json:\"header_picture\" bson:\"header_picture\"`\n\n\tTweets        *[]primitive.ObjectID `json:\"tweets\" bson:\"tweets\"`\n\tFollowings    *[]Owner              `json:\"followings\" bson:\"followings\"`\n\tFollowers     *[]Owner              `json:\"followers\" bson:\"followers\"`\n\tNotifications *[]Event              `json:\"notifications\" bson:\"notifications\"`\n\tLogs          *[]Event              `json:\"logs\" bson:\"logs\"`\n}\n\nfunc NewUser() *User {\n\tvar u User\n\tu.Name = \"Twitter User \"\n\tu.Tweets = &[]primitive.ObjectID{}\n\tu.Followings = &[]Owner{}\n\tu.Followers = &[]Owner{}\n\tu.Notifications = &[]Event{}\n\tu.Logs = &[]Event{}\n\treturn &u\n}\n\nfunc (u *User) HashPassword(plain string) (string, error) {\n\tif len(plain) == 0 {\n\t\treturn \"\", errors.New(\"password should not be empty\")\n\t}\n\th, err := bcrypt.GenerateFromPassword([]byte(plain), bcrypt.DefaultCost)\n\treturn string(h), err\n}\n\nfunc (u *User) CheckPassword(plain string) bool {\n\terr := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(plain))\n\treturn err == nil\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- model/user.go	(revision 3e30ce0bbc27a3bd580671e3e90c9f431f23c12f)
+++ model/user.go	(date 1611742666155)
@@ -26,7 +26,6 @@
 
 func NewUser() *User {
 	var u User
-	u.Name = "Twitter User "
 	u.Tweets = &[]primitive.ObjectID{}
 	u.Followings = &[]Owner{}
 	u.Followers = &[]Owner{}
