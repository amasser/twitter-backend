Index: store/user.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package store\n\nimport (\n\t\"context\"\n\t\"github.com/arman-aminian/twitter-backend/model\"\n\t\"go.mongodb.org/mongo-driver/bson\"\n\t\"go.mongodb.org/mongo-driver/bson/primitive\"\n\t\"go.mongodb.org/mongo-driver/mongo\"\n)\n\ntype UserStore struct {\n\tdb *mongo.Collection\n}\n\nfunc NewUserStore(db *mongo.Collection) *UserStore {\n\treturn &UserStore{\n\t\tdb: db,\n\t}\n}\n\nfunc (us *UserStore) Create(u *model.User) error {\n\t_, err := us.db.InsertOne(context.TODO(), u)\n\treturn err\n}\n\nfunc (us *UserStore) Remove(field, value string) error {\n\t_, err := us.db.DeleteOne(context.TODO(), bson.M{field: value})\n\treturn err\n}\n\nfunc (us *UserStore) Update(old *model.User, new *model.User) error {\n\tvar err error\n\tif old.Username != new.Username {\n\t\terr = us.Remove(\"_id\", old.Username)\n\t} else if old.Email != new.Email {\n\t\terr = us.Remove(\"email\", old.Email)\n\t} else if old.Password != new.Password {\n\t\terr = us.Remove(\"password\", old.Password)\n\t}\n\terr = us.Create(new)\n\treturn err\n}\n\nfunc (us *UserStore) UpdateProfile(u *model.User) error {\n\t_, err := us.db.UpdateOne(context.TODO(),\n\t\tbson.M{\"_id\": u.Username},\n\t\tbson.M{\"$set\": bson.M{\n\t\t\t\"name\":            u.Name,\n\t\t\t\"bio\":             u.Bio,\n\t\t\t\"profile_picture\": u.ProfilePicture,\n\t\t\t\"header_picture\":  u.HeaderPicture,\n\t\t},\n\t\t})\n\treturn err\n}\n\nfunc (us *UserStore) GetByEmail(email string) (*model.User, error) {\n\tvar u model.User\n\terr := us.db.FindOne(context.TODO(), bson.M{\"email\": email}).Decode(&u)\n\treturn &u, err\n}\n\nfunc (us *UserStore) GetByUsername(username string) (*model.User, error) {\n\tvar u model.User\n\terr := us.db.FindOne(context.TODO(), bson.M{\"_id\": username}).Decode(&u)\n\treturn &u, err\n}\n\nfunc (us *UserStore) AddFollower(u *model.User, follower *model.User) error {\n\t*u.Followers = append(*u.Followers, *model.NewOwner(follower.Username, follower.ProfilePicture, follower.Name, follower.Bio))\n\t_, err := us.db.UpdateOne(context.TODO(), bson.M{\"_id\": u.Username}, bson.M{\"$set\": bson.M{\"followers\": u.Followers}})\n\tif err != nil {\n\t\treturn err\n\t}\n\t*follower.Followings = append(*follower.Followings, *model.NewOwner(u.Username, u.ProfilePicture, u.Name, u.Bio))\n\t_, err = us.db.UpdateOne(context.TODO(), bson.M{\"_id\": follower.Username}, bson.M{\"$set\": bson.M{\"followings\": follower.Followings}})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (us *UserStore) RemoveFollower(u *model.User, follower *model.User) error {\n\tnewFollowers := &[]model.Owner{}\n\tfor _, o := range *u.Followers {\n\t\tif o.Username != follower.Username {\n\t\t\t*newFollowers = append(*newFollowers, o)\n\t\t}\n\t}\n\t_, err := us.db.UpdateOne(context.TODO(), bson.M{\"_id\": u.Username}, bson.M{\"$set\": bson.M{\"followers\": newFollowers}})\n\tif err != nil {\n\t\treturn err\n\t}\n\tu.Followers = newFollowers\n\n\tnewFollowings := &[]model.Owner{}\n\tfor _, o := range *follower.Followings {\n\t\tif o.Username != u.Username {\n\t\t\t*newFollowings = append(*newFollowings, o)\n\t\t}\n\t}\n\t_, err = us.db.UpdateOne(context.TODO(), bson.M{\"_id\": follower.Username}, bson.M{\"$set\": bson.M{\"followings\": newFollowings}})\n\tif err != nil {\n\t\treturn err\n\t}\n\tfollower.Followings = newFollowings\n\treturn nil\n}\n\nfunc (us *UserStore) IsFollower(username, followerUsername string) (bool, error) {\n\tu, err := us.GetByUsername(username)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tfollower, err := us.GetByUsername(followerUsername)\n\tif err != nil {\n\t\treturn false, nil\n\t}\n\tdoesFollow := false\n\tfor _, o := range *u.Followers {\n\t\tif o.Username == follower.Username {\n\t\t\tdoesFollow = true\n\t\t\tbreak\n\t\t}\n\t}\n\thasInFollowings := false\n\tfor _, o := range *follower.Followings {\n\t\tif o.Username == u.Username {\n\t\t\thasInFollowings = true\n\t\t\tbreak\n\t\t}\n\t}\n\treturn doesFollow && hasInFollowings, nil\n}\n\nfunc (us *UserStore) AddTweet(u *model.User, t *model.Tweet) error {\n\t*u.Tweets = append(*u.Tweets, t.ID)\n\t_, err := us.db.UpdateOne(context.TODO(), bson.M{\"_id\": u.Username}, bson.M{\"$set\": bson.M{\"tweets\": u.Tweets}})\n\treturn err\n}\n\nfunc (us *UserStore) RemoveTweet(u *model.User, id *string) error {\n\toid, err := primitive.ObjectIDFromHex(*id)\n\tif err != nil {\n\t\treturn err\n\t}\n\tnewTweets := &[]primitive.ObjectID{}\n\tfor _, tid := range *u.Tweets {\n\t\tif tid != oid {\n\t\t\t*newTweets = append(*newTweets, tid)\n\t\t}\n\t}\n\t_, err = us.db.UpdateOne(context.TODO(), bson.M{\"_id\": u.Username}, bson.M{\"$set\": bson.M{\"tweets\": newTweets}})\n\treturn err\n}\n\nfunc (us *UserStore) AddLog(u *model.User, e *model.Event) error {\n\t*u.Logs = append(*u.Logs, *e)\n\t_, err := us.db.UpdateOne(context.TODO(), bson.M{\"_id\": u.Username}, bson.M{\"$set\": bson.M{\"logs\": u.Logs}})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (us *UserStore) AddNotification(u *model.User, e *model.Event) error {\n\t*u.Notifications = append(*u.Notifications, *e)\n\t_, err := us.db.UpdateOne(context.TODO(), bson.M{\"_id\": u.Username}, bson.M{\"$set\": bson.M{\"notifications\": u.Notifications}})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (us *UserStore) GetUserListFromUsernameList(usernames []string) (*[]model.User, error) {\n\tvar users []model.User\n\tquery := bson.M{\"_id\": bson.M{\"$in\": usernames}}\n\tres, err := us.db.Find(context.TODO(), query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// var episodes []bson.M\n\tif err = res.All(context.TODO(), &users); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &users, err\n}\n\nfunc (us *UserStore) GetTweetIdListFromUsernameList(usernames []string) (*[]primitive.ObjectID, error) {\n\tvar users []model.User\n\tquery := bson.M{\"_id\": bson.M{\"$in\": usernames}}\n\tres, err := us.db.Find(context.TODO(), query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// var episodes []bson.M\n\tif err = res.All(context.TODO(), &users); err != nil {\n\t\treturn nil, err\n\t}\n\tvar tweetsId []primitive.ObjectID\n\tfor _, user := range users {\n\t\ttweetsId = append(tweetsId, *user.Tweets...)\n\t}\n\treturn &tweetsId, err\n}\n\nfunc (us *UserStore) GetUsernameSearchResult(username string) (*[]model.Owner, error) {\n\tvar users []model.User\n\treg := \"^\" + username // usernames that starts with \"query\"\n\tquery := bson.M{\"_id\": bson.M{\"$regex\": reg}}\n\tres, err := us.db.Find(context.TODO(), query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err = res.All(context.TODO(), &users); err != nil {\n\t\treturn nil, err\n\t}\n\tvar result []model.Owner\n\tfor _, user := range users {\n\t\tresult = append(result, model.Owner{\n\t\t\tUsername:       user.Username,\n\t\t\tProfilePicture: user.ProfilePicture,\n\t\t\tName:           user.Name,\n\t\t\tBio:            user.Bio,\n\t\t})\n\t}\n\treturn &result, err\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- store/user.go	(revision f5b85206b39c140fd7a98952034ffa683e55c513)
+++ store/user.go	(date 1611789308337)
@@ -67,12 +67,12 @@
 }
 
 func (us *UserStore) AddFollower(u *model.User, follower *model.User) error {
-	*u.Followers = append(*u.Followers, *model.NewOwner(follower.Username, follower.ProfilePicture, follower.Name, follower.Bio))
+	*u.Followers = append(*u.Followers, *model.NewOwner(&follower.Username, &follower.ProfilePicture, &follower.Name, &follower.Bio))
 	_, err := us.db.UpdateOne(context.TODO(), bson.M{"_id": u.Username}, bson.M{"$set": bson.M{"followers": u.Followers}})
 	if err != nil {
 		return err
 	}
-	*follower.Followings = append(*follower.Followings, *model.NewOwner(u.Username, u.ProfilePicture, u.Name, u.Bio))
+	*follower.Followings = append(*follower.Followings, *model.NewOwner(&u.Username, &u.ProfilePicture, &u.Name, &u.Bio))
 	_, err = us.db.UpdateOne(context.TODO(), bson.M{"_id": follower.Username}, bson.M{"$set": bson.M{"followings": follower.Followings}})
 	if err != nil {
 		return err
@@ -83,7 +83,7 @@
 func (us *UserStore) RemoveFollower(u *model.User, follower *model.User) error {
 	newFollowers := &[]model.Owner{}
 	for _, o := range *u.Followers {
-		if o.Username != follower.Username {
+		if *o.Username != follower.Username {
 			*newFollowers = append(*newFollowers, o)
 		}
 	}
@@ -92,10 +92,10 @@
 		return err
 	}
 	u.Followers = newFollowers
-
+	
 	newFollowings := &[]model.Owner{}
 	for _, o := range *follower.Followings {
-		if o.Username != u.Username {
+		if *o.Username != u.Username {
 			*newFollowings = append(*newFollowings, o)
 		}
 	}
@@ -118,14 +118,14 @@
 	}
 	doesFollow := false
 	for _, o := range *u.Followers {
-		if o.Username == follower.Username {
+		if *o.Username == follower.Username {
 			doesFollow = true
 			break
 		}
 	}
 	hasInFollowings := false
 	for _, o := range *follower.Followings {
-		if o.Username == u.Username {
+		if *o.Username == u.Username {
 			hasInFollowings = true
 			break
 		}
@@ -218,10 +218,10 @@
 	var result []model.Owner
 	for _, user := range users {
 		result = append(result, model.Owner{
-			Username:       user.Username,
-			ProfilePicture: user.ProfilePicture,
-			Name:           user.Name,
-			Bio:            user.Bio,
+			Username:       &user.Username,
+			ProfilePicture: &user.ProfilePicture,
+			Name:           &user.Name,
+			Bio:            &user.Bio,
 		})
 	}
 	return &result, err
Index: store/tweet.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package store\n\nimport (\n\t\"context\"\n\t\"github.com/arman-aminian/twitter-backend/model\"\n\t\"go.mongodb.org/mongo-driver/bson\"\n\t\"go.mongodb.org/mongo-driver/bson/primitive\"\n\t\"go.mongodb.org/mongo-driver/mongo\"\n\t\"regexp\"\n\t\"time\"\n)\n\ntype TweetStore struct {\n\tdb *mongo.Collection\n}\n\nfunc NewTweetStore(db *mongo.Collection) *TweetStore {\n\treturn &TweetStore{\n\t\tdb: db,\n\t}\n}\n\nfunc (ts *TweetStore) CreateTweet(t *model.Tweet) error {\n\t_, err := ts.db.InsertOne(context.TODO(), t)\n\treturn err\n}\n\nfunc (ts *TweetStore) RemoveTweet(t *model.Tweet) error {\n\t_, err := ts.db.DeleteOne(context.TODO(), t)\n\treturn err\n}\n\nfunc (ts *TweetStore) GetTweetById(id *string) (*model.Tweet, error) {\n\tvar t model.Tweet\n\toid, err := primitive.ObjectIDFromHex(*id)\n\tif err != nil {\n\t\treturn &t, nil\n\t}\n\terr = ts.db.FindOne(context.TODO(), bson.M{\"_id\": oid}).Decode(&t)\n\treturn &t, err\n}\n\nfunc (ts *TweetStore) GetTweets(tweets []string) (*[]model.Tweet, error) {\n\tvar ids []primitive.ObjectID\n\tfor _, tweet := range tweets {\n\t\toid, _ := primitive.ObjectIDFromHex(tweet)\n\t\tids = append(ids, oid)\n\t}\n\tvar result []model.Tweet\n\tquery := bson.M{\"_id\": bson.M{\"$in\": ids}}\n\tres, err := ts.db.Find(context.TODO(), query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err = res.All(context.TODO(), &result); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &result, err\n}\n\nfunc (ts *TweetStore) GetAllTweets() ([]bson.M, error) {\n\tvar ret []bson.M\n\tcur, err := ts.db.Find(context.TODO(), bson.M{})\n\tif err = cur.All(context.TODO(), &ret); err != nil {\n\t\treturn nil, err\n\t}\n\treturn ret, nil\n}\n\nfunc (ts *TweetStore) AddCommentToTweet(parent *model.Tweet, child *model.CommentTweet) error {\n\t*parent.Comments = append(*parent.Comments, *child)\n\t_, err := ts.db.UpdateOne(context.TODO(), bson.M{\"_id\": parent.ID}, bson.M{\"$set\": bson.M{\"comments\": parent.Comments}})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (ts *TweetStore) LikeTweet(t *model.Tweet, u *model.User) error {\n\t*t.Likes = append(*t.Likes, *model.NewOwner(u.Username, u.ProfilePicture, u.Name, u.Bio))\n\t_, err := ts.db.UpdateOne(context.TODO(), bson.M{\"_id\": t.ID}, bson.M{\"$set\": bson.M{\"likes\": t.Likes}})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (ts *TweetStore) UnLikeTweet(t *model.Tweet, u *model.User) error {\n\tnewLikes := &[]model.Owner{}\n\tfor _, o := range *t.Likes {\n\t\tif o.Username != u.Username {\n\t\t\t*newLikes = append(*newLikes, o)\n\t\t}\n\t}\n\t_, err := ts.db.UpdateOne(context.TODO(), bson.M{\"_id\": t.ID}, bson.M{\"$set\": bson.M{\"likes\": newLikes}})\n\tif err != nil {\n\t\treturn err\n\t}\n\tt.Likes = newLikes\n\treturn nil\n}\n\nfunc (ts *TweetStore) Retweet(t *model.Tweet, u *model.User) error {\n\t*t.Retweets = append(*t.Retweets, *model.NewOwner(u.Username, u.ProfilePicture, u.Name, u.Bio))\n\t_, err := ts.db.UpdateOne(context.TODO(), bson.M{\"_id\": t.ID}, bson.M{\"$set\": bson.M{\"retweets\": t.Retweets}})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (ts *TweetStore) UnRetweet(t *model.Tweet, u *model.User) error {\n\tnewRetweets := &[]model.Owner{}\n\tfor _, o := range *t.Retweets {\n\t\tif o.Username != u.Username {\n\t\t\t*newRetweets = append(*newRetweets, o)\n\t\t}\n\t}\n\t_, err := ts.db.UpdateOne(context.TODO(), bson.M{\"_id\": t.ID}, bson.M{\"$set\": bson.M{\"retweets\": newRetweets}})\n\tif err != nil {\n\t\treturn err\n\t}\n\tt.Retweets = newRetweets\n\treturn nil\n}\n\nfunc (ts *TweetStore) ExtractHashtags(t *model.Tweet) map[string]int {\n\tmatchTags := regexp.MustCompile(`\\B[#]\\w*[a-zA-Z]+\\w*`)\n\tres := map[string]int{}\n\tfor _, v := range matchTags.FindAllString(t.Text, -1) {\n\t\tvn := v[1:]\n\t\tif _, ok := res[vn]; ok {\n\t\t\tres[vn] += 1\n\t\t} else {\n\t\t\tres[vn] = 1\n\t\t}\n\t}\n\treturn res\n}\n\nfunc (ts *TweetStore) GetTimelineFromTweetIDs(tweetsIDs []primitive.ObjectID, day int) (*[]model.Tweet, error) {\n\tdate := time.Now().AddDate(0, 0, day).Format(\"2006-01-02\")\n\tvar tweets []model.Tweet\n\tfilter := bson.M{\n\t\t\"$and\": []bson.M{\n\t\t\t{\"_id\": bson.M{\"$in\": tweetsIDs}},\n\t\t\t{\"date\": date},\n\t\t},\n\t}\n\n\tres, err := ts.db.Find(context.TODO(), filter)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err = res.All(context.TODO(), &tweets); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &tweets, err\n}\n\nfunc (ts *TweetStore) GetTweetSearchResult(query string) (*[]model.Tweet, error) {\n\tvar result []model.Tweet\n\tres, err := ts.db.Find(context.Background(), bson.M{\"$text\": bson.M{\"$search\": query}})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err = res.All(context.TODO(), &result); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &result, nil\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- store/tweet.go	(revision f5b85206b39c140fd7a98952034ffa683e55c513)
+++ store/tweet.go	(date 1611789308313)
@@ -77,7 +77,7 @@
 }
 
 func (ts *TweetStore) LikeTweet(t *model.Tweet, u *model.User) error {
-	*t.Likes = append(*t.Likes, *model.NewOwner(u.Username, u.ProfilePicture, u.Name, u.Bio))
+	*t.Likes = append(*t.Likes, *model.NewOwner(&u.Username, &u.ProfilePicture, &u.Name, &u.Bio))
 	_, err := ts.db.UpdateOne(context.TODO(), bson.M{"_id": t.ID}, bson.M{"$set": bson.M{"likes": t.Likes}})
 	if err != nil {
 		return err
@@ -88,7 +88,7 @@
 func (ts *TweetStore) UnLikeTweet(t *model.Tweet, u *model.User) error {
 	newLikes := &[]model.Owner{}
 	for _, o := range *t.Likes {
-		if o.Username != u.Username {
+		if *o.Username != u.Username {
 			*newLikes = append(*newLikes, o)
 		}
 	}
@@ -101,7 +101,7 @@
 }
 
 func (ts *TweetStore) Retweet(t *model.Tweet, u *model.User) error {
-	*t.Retweets = append(*t.Retweets, *model.NewOwner(u.Username, u.ProfilePicture, u.Name, u.Bio))
+	*t.Retweets = append(*t.Retweets, *model.NewOwner(&u.Username, &u.ProfilePicture, &u.Name, &u.Bio))
 	_, err := ts.db.UpdateOne(context.TODO(), bson.M{"_id": t.ID}, bson.M{"$set": bson.M{"retweets": t.Retweets}})
 	if err != nil {
 		return err
@@ -112,7 +112,7 @@
 func (ts *TweetStore) UnRetweet(t *model.Tweet, u *model.User) error {
 	newRetweets := &[]model.Owner{}
 	for _, o := range *t.Retweets {
-		if o.Username != u.Username {
+		if *o.Username != u.Username {
 			*newRetweets = append(*newRetweets, o)
 		}
 	}
Index: db/db.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package db\n\nimport (\n\t\"context\"\n\t\"go.mongodb.org/mongo-driver/bson\"\n\t\"go.mongodb.org/mongo-driver/mongo\"\n\t\"go.mongodb.org/mongo-driver/mongo/options\"\n\t\"log\"\n\t\"sync\"\n)\n\nvar clientInstance *mongo.Client\nvar clientInstanceError error\nvar mongoOnce sync.Once\n\nconst (\n\t//PATH = \"mongodb://localhost:27017\"\n\tPATH     = \"mongodb+srv://arman-aminian:aaaa1234@twitter-db.ugqqk.mongodb.net/twitter?retryWrites=true&w=majority\"\n\tDB       = \"twitter\"\n\tUSERS    = \"customers\"\n\tTWEETS   = \"tweets\"\n\tHASHTAGS = \"hashtags\"\n)\n\nfunc GetMongoClient() (*mongo.Client, error) {\n\tmongoOnce.Do(func() {\n\t\tclientOptions := options.Client().ApplyURI(PATH)\n\t\tclient, err := mongo.Connect(context.TODO(), clientOptions)\n\t\tif err != nil {\n\t\t\tclientInstanceError = err\n\t\t} else {\n\t\t\terr = client.Ping(context.TODO(), nil)\n\t\t\tif err != nil {\n\t\t\t\tclientInstanceError = err\n\t\t\t}\n\t\t}\n\t\tclientInstance = client\n\t})\n\treturn clientInstance, clientInstanceError\n}\n\nfunc SetupUsersDb(mongoClient *mongo.Client) *mongo.Collection {\n\tusersDb := mongoClient.Database(\"twitter_db\").Collection(\"users\")\n\tcreateUniqueIndices(usersDb, \"email\")\n\treturn usersDb\n}\n\nfunc SetupHashtagsDb(mongoClient *mongo.Client) *mongo.Collection {\n\thashtagsDb := mongoClient.Database(\"twitter_db\").Collection(\"hashtags\")\n\tcreateUniqueIndices(hashtagsDb, \"name\")\n\treturn hashtagsDb\n}\n\nfunc createUniqueIndices(db *mongo.Collection, field string) {\n\t_, err := db.Indexes().CreateOne(\n\t\tcontext.Background(),\n\t\tmongo.IndexModel{\n\t\t\tKeys:    bson.D{{Key: field, Value: 1}},\n\t\t\tOptions: options.Index().SetUnique(true),\n\t\t},\n\t)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc SetupTweetsDb(mongoClient *mongo.Client) *mongo.Collection {\n\ttweetsDb := mongoClient.Database(\"twitter_db\").Collection(\"tweets\")\n\t_, err := tweetsDb.Indexes().CreateOne(\n\t\tcontext.Background(),\n\t\tmongo.IndexModel{\n\t\t\tKeys:    bson.D{{Key: \"text\", Value: \"text\"}},\n\t\t\tOptions: nil,\n\t\t})\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn tweetsDb\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- db/db.go	(revision f5b85206b39c140fd7a98952034ffa683e55c513)
+++ db/db.go	(date 1611808771208)
@@ -14,7 +14,7 @@
 var mongoOnce sync.Once
 
 const (
-	//PATH = "mongodb://localhost:27017"
+	// PATH = "mongodb://localhost:27017"
 	PATH     = "mongodb+srv://arman-aminian:aaaa1234@twitter-db.ugqqk.mongodb.net/twitter?retryWrites=true&w=majority"
 	DB       = "twitter"
 	USERS    = "customers"
Index: handler/response.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package handler\n\nimport (\n\t\"github.com/arman-aminian/twitter-backend/model\"\n\t\"github.com/arman-aminian/twitter-backend/user\"\n\t\"github.com/arman-aminian/twitter-backend/utils\"\n\t\"github.com/labstack/echo/v4\"\n\t\"go.mongodb.org/mongo-driver/bson/primitive\"\n\t\"time\"\n)\n\ntype userResponse struct {\n\tUser struct {\n\t\tUsername       string `json:\"username\" bson:\"_id\"`\n\t\tEmail          string `json:\"email\"`\n\t\tName           string `json:\"name\"`\n\t\tBio            string `json:\"bio\"`\n\t\tProfilePicture string `json:\"profile_picture\"`\n\t\tToken          string `json:\"token\"`\n\t} `json:\"user\"`\n}\n\nfunc newUserResponse(u *model.User) *userResponse {\n\tr := new(userResponse)\n\tr.User.Username = u.Username\n\tr.User.Email = u.Email\n\tr.User.Name = u.Name\n\tr.User.Bio = u.Bio\n\tr.User.ProfilePicture = u.ProfilePicture\n\tr.User.Token = utils.GenerateJWT(u.Username)\n\treturn r\n}\n\ntype profileResponse struct {\n\tProfile struct {\n\t\tName           string                `json:\"name\"`\n\t\tIsFollowing    bool                  `json:\"is_following, omitempty\"`\n\t\tUsername       string                `json:\"username\" bson:\"_id\"`\n\t\tBio            string                `json:\"bio\"`\n\t\tProfilePicture string                `json:\"profile_picture\"`\n\t\tHeaderPicture  string                `json:\"header_picture\"`\n\t\tTweets         *[]primitive.ObjectID `json:\"tweets\"`\n\t\tFollowings     *[]model.Owner        `json:\"followings\"`\n\t\tFollowers      *[]model.Owner        `json:\"followers\"`\n\t} `json:\"profile\"`\n}\n\nfunc newProfileResponse(us user.Store, srcUsername string, u *model.User) *profileResponse {\n\tr := new(profileResponse)\n\tr.Profile.Name = u.Name\n\tr.Profile.Username = u.Username\n\tr.Profile.Bio = u.Bio\n\tr.Profile.ProfilePicture = u.ProfilePicture\n\tr.Profile.HeaderPicture = u.HeaderPicture\n\tr.Profile.Tweets = u.Tweets\n\tr.Profile.Followings = u.Followings\n\tr.Profile.Followers = u.Followers\n\tr.Profile.IsFollowing, _ = us.IsFollower(u.Username, srcUsername)\n\treturn r\n}\n\ntype FollowersAndFollowingListResponse struct {\n\tFollowers   *[]model.Owner `json:\"followers\" bson:\"followers\"`\n\tFollowings  *[]model.Owner `json:\"followings\" bson:\"followings\"`\n\tIsFollowing bool           `json:\"is_following, omitempty\"`\n}\n\nfunc newFollowingAndFollowersList(us user.Store, srcUsername string, u *model.User) *FollowersAndFollowingListResponse {\n\tl := new(FollowersAndFollowingListResponse)\n\tl.Followers = u.Followers\n\tl.Followings = u.Followings\n\tl.IsFollowing, _ = us.IsFollower(u.Username, srcUsername)\n\treturn l\n}\n\ntype OwnerListResponse struct {\n\tUsers *[]model.Owner `json:\"users\"`\n}\n\nfunc newOwnerList(users *[]model.Owner) *OwnerListResponse {\n\tl := new(OwnerListResponse)\n\tl.Users = users\n\treturn l\n}\n\ntype SingleEventResponse struct {\n\tMode      string      `json:\"mode\"`\n\tSource    model.Owner `json:\"source\"`\n\tTarget    model.Owner `json:\"target\"`\n\tContent   string      `json:\"content\"`\n\tTimeStamp time.Time   `json:\"timestamp\"`\n}\n\ntype EventListResponse struct {\n\tEvents []SingleEventResponse `json:\"events\"`\n}\n\nfunc newLogsList(u *model.User) *EventListResponse {\n\tret := new(EventListResponse)\n\tfor _, e := range *u.Logs {\n\t\tl := new(SingleEventResponse)\n\t\tl.Mode = e.Mode\n\t\tl.Source = e.Source\n\t\tl.Target = e.Target\n\t\tl.Content = e.Content\n\t\tl.TimeStamp = e.TimeStamp\n\t\tret.Events = append(ret.Events, *l)\n\t}\n\treturn ret\n}\n\nfunc newNotificationsList(u *model.User) *EventListResponse {\n\tret := new(EventListResponse)\n\tfor _, e := range *u.Notifications {\n\t\tl := new(SingleEventResponse)\n\t\tl.Mode = e.Mode\n\t\tl.Source = e.Source\n\t\tl.Target = e.Target\n\t\tl.Content = e.Content\n\t\tl.TimeStamp = e.TimeStamp\n\t\tret.Events = append(ret.Events, *l)\n\t}\n\treturn ret\n}\n\n//\t********************** Tweet Response **********************\n\ntype tweetResponse struct {\n\tID            string                `json:\"id\"`\n\tText          string                `json:\"text\"`\n\tMedia         string                `json:\"media\"`\n\tLiked         bool                  `json:\"liked\"`\n\tLikesCount    int                   `json:\"likes_count\"`\n\tRetweeted     bool                  `json:\"retweeted\"`\n\tRetweetsCount int                   `json:\"retweets_count\"`\n\tTime          time.Time             `json:\"time\" bson:\"time\"`\n\tOwner         model.Owner           `json:\"owner\"`\n\tParents       *[]model.CommentTweet `json:\"parents\" bson:\"parents\"`\n\tComments      *[]model.CommentTweet `json:\"comments\" bson:\"comments\"`\n}\n\ntype singleTweetResponse struct {\n\tTweet *tweetResponse `json:\"tweet\"`\n}\n\ntype tweetsResponse struct {\n\tTweets []tweetResponse `json:\"tweets\"`\n}\n\ntype tweetListResponse struct {\n\tTweets      []tweetResponse `json:\"tweets\"`\n\tTweetsCount int             `json:\"tweetsCount\"`\n}\n\nfunc newTweetsResponse(username string, tweets *[]model.Tweet) *tweetsResponse {\n\ttr := make([]tweetResponse, len(*tweets))\n\tif tweets == nil {\n\t\treturn &tweetsResponse{tr}\n\t}\n\tfor i, tweet := range *tweets {\n\t\ttr[i].ID = tweet.ID.Hex()\n\t\ttr[i].Text = tweet.Text\n\t\ttr[i].Parents = tweet.Parents\n\t\ttr[i].Comments = tweet.Comments\n\t\ttr[i].Media = tweet.Media\n\t\ttr[i].Time = tweet.Time\n\n\t\tfor _, t := range *tweet.Likes {\n\t\t\tif t.Username == username {\n\t\t\t\ttr[i].Liked = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\ttr[i].LikesCount = len(*tweet.Likes)\n\t\tfor _, t := range *tweet.Retweets {\n\t\t\tif t.Username == username {\n\t\t\t\ttr[i].Retweeted = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\ttr[i].RetweetsCount = len(*tweet.Retweets)\n\t\ttr[i].Owner.Username = tweet.Owner.Username\n\t\ttr[i].Owner.ProfilePicture = tweet.Owner.ProfilePicture\n\t}\n\treturn &tweetsResponse{tr}\n}\n\nfunc newTweetResponse(c echo.Context, t *model.Tweet) *singleTweetResponse {\n\ttr := new(tweetResponse)\n\ttr.ID = t.ID.Hex()\n\ttr.Text = t.Text\n\ttr.Parents = t.Parents\n\ttr.Comments = t.Comments\n\ttr.Media = t.Media\n\ttr.Time = t.Time\n\tfor _, u := range *t.Likes {\n\t\tif u.Username == stringFieldFromToken(c, \"username\") {\n\t\t\ttr.Liked = true\n\t\t\tbreak\n\t\t}\n\t}\n\ttr.LikesCount = len(*t.Likes)\n\tfor _, u := range *t.Retweets {\n\t\tif u.Username == stringFieldFromToken(c, \"username\") {\n\t\t\ttr.Retweeted = true\n\t\t\tbreak\n\t\t}\n\t}\n\ttr.RetweetsCount = len(*t.Retweets)\n\ttr.Owner.Username = t.Owner.Username\n\ttr.Owner.ProfilePicture = t.Owner.ProfilePicture\n\n\treturn &singleTweetResponse{tr}\n}\n\nfunc newTweetListResponse(c echo.Context, username string, tweets *[]model.Tweet, size int) *tweetListResponse {\n\ttr := make([]tweetResponse, size)\n\tif tweets == nil {\n\t\treturn &tweetListResponse{tr, size}\n\t}\n\tfor i, tweet := range *tweets {\n\t\ttr[i].ID = tweet.ID.Hex()\n\t\ttr[i].Text = tweet.Text\n\t\ttr[i].Parents = tweet.Parents\n\t\ttr[i].Comments = tweet.Comments\n\t\ttr[i].Media = tweet.Media\n\t\ttr[i].Time = tweet.Time\n\n\t\tfor _, t := range *tweet.Likes {\n\t\t\tif t.Username == username {\n\t\t\t\ttr[i].Liked = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\ttr[i].LikesCount = len(*tweet.Likes)\n\t\tfor _, t := range *tweet.Retweets {\n\t\t\tif t.Username == username {\n\t\t\t\ttr[i].Retweeted = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\ttr[i].RetweetsCount = len(*tweet.Retweets)\n\t\ttr[i].Owner.Username = tweet.Owner.Username\n\t\ttr[i].Owner.ProfilePicture = tweet.Owner.ProfilePicture\n\t}\n\treturn &tweetListResponse{tr, size}\n}\n\ntype tweetLikeAndRetweetResponse struct {\n\tLikesList    *[]model.Owner `json:\"likes\" bson:\"likes\"`\n\tRetweetsList *[]model.Owner `json:\"retweets\" bson:\"retweets\"`\n}\n\nfunc newLikeAndRetweetResponse(t *model.Tweet) *tweetLikeAndRetweetResponse {\n\ttr := new(tweetLikeAndRetweetResponse)\n\ttr.LikesList = t.Likes\n\ttr.RetweetsList = t.Retweets\n\treturn tr\n}\n\ntype timelineResponse struct {\n\ttimeline *[]model.Tweet\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- handler/response.go	(revision f5b85206b39c140fd7a98952034ffa683e55c513)
+++ handler/response.go	(date 1611810596318)
@@ -118,7 +118,7 @@
 		l.Target = e.Target
 		l.Content = e.Content
 		l.TimeStamp = e.TimeStamp
-		ret.Events = append(ret.Events, *l)
+		ret.Events = append([]SingleEventResponse{*l}, ret.Events...)
 	}
 	return ret
 }
@@ -166,14 +166,14 @@
 		tr[i].Time = tweet.Time
 
 		for _, t := range *tweet.Likes {
-			if t.Username == username {
+			if *t.Username == username {
 				tr[i].Liked = true
 				break
 			}
 		}
 		tr[i].LikesCount = len(*tweet.Likes)
 		for _, t := range *tweet.Retweets {
-			if t.Username == username {
+			if *t.Username == username {
 				tr[i].Retweeted = true
 				break
 			}
@@ -194,14 +194,14 @@
 	tr.Media = t.Media
 	tr.Time = t.Time
 	for _, u := range *t.Likes {
-		if u.Username == stringFieldFromToken(c, "username") {
+		if *u.Username == stringFieldFromToken(c, "username") {
 			tr.Liked = true
 			break
 		}
 	}
 	tr.LikesCount = len(*t.Likes)
 	for _, u := range *t.Retweets {
-		if u.Username == stringFieldFromToken(c, "username") {
+		if *u.Username == stringFieldFromToken(c, "username") {
 			tr.Retweeted = true
 			break
 		}
@@ -227,14 +227,14 @@
 		tr[i].Time = tweet.Time
 
 		for _, t := range *tweet.Likes {
-			if t.Username == username {
+			if *t.Username == username {
 				tr[i].Liked = true
 				break
 			}
 		}
 		tr[i].LikesCount = len(*tweet.Likes)
 		for _, t := range *tweet.Retweets {
-			if t.Username == username {
+			if *t.Username == username {
 				tr[i].Retweeted = true
 				break
 			}
Index: handler/tweet.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package handler\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/arman-aminian/twitter-backend/model\"\n\t\"github.com/arman-aminian/twitter-backend/utils\"\n\t\"github.com/labstack/echo/v4\"\n\t\"go.mongodb.org/mongo-driver/bson/primitive\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"sort\"\n\t\"time\"\n)\n\n// CreateArticle godoc\n// @Summary Create an tweet\n// @Description Create an tweet\n// @ID create-tweet\n// @Tags article\n// @Accept  json\n// @Produce  json\n// @Param article body tweetCreateRequest true \"Article to create\"\n// @Success 201 {object} singleTweetResponse\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /articles [post]\nfunc (h *Handler) CreateTweet(c echo.Context) error {\n\tt := model.NewTweet()\n\n\tt.ID = primitive.NewObjectID()\n\tt.Text = c.FormValue(\"text\")\n\n\tfile, err := c.FormFile(\"media\")\n\tif err == nil {\n\t\tsrc, err := file.Open()\n\t\tif err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tdefer src.Close()\n\n\t\tmediaFolderName := \"media/tweet-assets/\"\n\t\tmediaPath := mediaFolderName + file.Filename\n\t\tdst, err := os.Create(mediaPath)\n\t\tif err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tdefer dst.Close()\n\n\t\tif _, err = io.Copy(dst, src); err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tt.Media = mediaPath\n\t} else {\n\t\t// Tweet without media\n\t\tt.Media = \"\"\n\t}\n\n\tu, err := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\tt.Owner.Username = u.Username\n\tt.Owner.ProfilePicture = u.ProfilePicture\n\tt.Time = time.Now()\n\tt.Date = time.Now().Format(\"2006-01-02\")\n\n\tparentId := c.FormValue(\"parent\")\n\tif parentId != \"\" {\n\t\tp, err := h.tweetStore.GetTweetById(&parentId)\n\t\tif err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tif p == nil {\n\t\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t\t}\n\n\t\tpid, _ := h.tweetStore.GetTweetById(&parentId)\n\t\t//\n\t\ttemp := *model.NewCommentTweet(*pid)\n\t\ttemp.CommentsCount = temp.CommentsCount + 1\n\t\t*t.Parents = append(*p.Parents, temp)\n\t\terr = h.tweetStore.AddCommentToTweet(p, model.NewCommentTweet(*t))\n\t\tif err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t}\n\n\terr = h.tweetStore.CreateTweet(t)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\terr = h.userStore.AddTweet(u, t)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\n\thashtags := h.tweetStore.ExtractHashtags(t)\n\tfor name, cnt := range hashtags {\n\t\th.AddHashtag(name, t, cnt)\n\t}\n\n\tres := newTweetResponse(c, t)\n\treturn c.JSON(http.StatusCreated, res)\n}\n\nfunc (h *Handler) GetTweetAssetFile(c echo.Context) error {\n\tmediaFolderName := \"media/tweet-assets/\"\n\tmediaPath := mediaFolderName + c.Param(\"filename\")\n\treturn c.File(mediaPath)\n}\n\nfunc (h *Handler) GetTweet(c echo.Context) error {\n\tid := c.Param(\"id\")\n\tt, err := h.tweetStore.GetTweetById(&id)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif t == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\n\treturn c.JSON(http.StatusOK, newTweetResponse(c, t))\n}\n\nfunc (h *Handler) GetTweets(c echo.Context) error {\n\ttweets := &model.TweetIdList{}\n\terr := c.Bind(tweets)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\tfmt.Println(tweets)\n\tif len(tweets.Tweets) == 0 {\n\t\treturn c.JSON(http.StatusBadRequest, utils.NewError(errors.New(\"nothing to search for\")))\n\t}\n\tres, err := h.tweetStore.GetTweets(tweets.Tweets)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\n\t// sort tweets\n\tsorted := *res\n\tsort.Slice(sorted, func(i, j int) bool {\n\t\treturn sorted[i].Time.After(sorted[j].Time)\n\t})\n\treturn c.JSON(http.StatusOK, newTweetsResponse(stringFieldFromToken(c, \"username\"), &sorted))\n}\n\nfunc (h *Handler) DeleteTweet(c echo.Context) error {\n\tid := c.Param(\"id\")\n\tt, err := h.tweetStore.GetTweetById(&id)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif t == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\n\tu, err := h.userStore.GetByUsername(t.Owner.Username)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tif u.Username != t.Owner.Username {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"you can only delete you tweets\")))\n\t}\n\n\terr = h.userStore.RemoveTweet(u, &id)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\n\terr = h.tweetStore.RemoveTweet(t)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\n\thashtags := h.tweetStore.ExtractHashtags(t)\n\th.hashtagStore.DeleteTweetHashtags(t, hashtags)\n\n\treturn c.JSON(http.StatusOK, newTweetResponse(c, t))\n}\n\n// GetArticle godoc\n// @Summary Get an article\n// @Description Get an article. Auth not required\n// @ID get-article\n// @Tags article\n// @Accept  json\n// @Produce  json\n// @Param slug path string true \"Slug of the article to get\"\n// @Success 200 {object} singleArticleResponse\n// @Failure 400 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Router /articles/{slug} [get]\nfunc (h *Handler) GetTweetLikeAndRetweetList(c echo.Context) error {\n\tid := c.Param(\"id\")\n\tt, err := h.tweetStore.GetTweetById(&id)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif t == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\n\treturn c.JSON(http.StatusOK, newLikeAndRetweetResponse(t))\n}\n\n// GetArticle godoc\n// @Summary Get an article\n// @Description Get an article. Auth not required\n// @ID get-article\n// @Tags article\n// @Accept  json\n// @Produce  json\n// @Param slug path string true \"Slug of the article to get\"\n// @Success 200 {object} singleArticleResponse\n// @Failure 400 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Router /articles/{slug} [get]\nfunc (h *Handler) GetRetweetList(c echo.Context) error {\n\tid := c.Param(\"id\")\n\tt, err := h.tweetStore.GetTweetById(&id)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif t == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\n\treturn c.JSON(http.StatusOK, newLikeAndRetweetResponse(t))\n}\n\n// Favorite godoc\n// @Summary Favorite an article\n// @Description Favorite an article. Auth is required\n// @ID favorite\n// @Tags favorite\n// @Accept  json\n// @Produce  json\n// @Param slug path string true \"Slug of the article that you want to favorite\"\n// @Success 200 {object} singleArticleResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /articles/{slug}/favorite [post]\nfunc (h *Handler) Like(c echo.Context) error {\n\tid := c.Param(\"id\")\n\tt, err := h.tweetStore.GetTweetById(&id)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif t == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tu, err := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tfor _, o := range *t.Likes {\n\t\tif u.Username == o.Username {\n\t\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"already liked\")))\n\t\t}\n\t}\n\n\tif err := h.tweetStore.LikeTweet(t, u); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\n\te := h.CreateLikeEvent(u, t)\n\terr = h.userStore.AddLog(u, e)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\ttarget, err := h.userStore.GetByUsername(t.Owner.Username)\n\tif target == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\terr = h.userStore.AddNotification(target, e)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\n\treturn c.JSON(http.StatusOK, newTweetResponse(c, t))\n}\n\n// Favorite godoc\n// @Summary Favorite an article\n// @Description Favorite an article. Auth is required\n// @ID favorite\n// @Tags favorite\n// @Accept  json\n// @Produce  json\n// @Param slug path string true \"Slug of the article that you want to favorite\"\n// @Success 200 {object} singleArticleResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /articles/{slug}/favorite [post]\nfunc (h *Handler) UnLike(c echo.Context) error {\n\tid := c.Param(\"id\")\n\tt, err := h.tweetStore.GetTweetById(&id)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif t == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tu, err := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tb := false\n\tfor _, o := range *t.Likes {\n\t\tif u.Username == o.Username {\n\t\t\tb = true\n\t\t}\n\t}\n\tif !b {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"hasn't liked\")))\n\t}\n\n\tif err := h.tweetStore.UnLikeTweet(t, u); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\n\treturn c.JSON(http.StatusOK, newTweetResponse(c, t))\n}\n\n// Favorite godoc\n// @Summary Favorite an article\n// @Description Favorite an article. Auth is required\n// @ID favorite\n// @Tags favorite\n// @Accept  json\n// @Produce  json\n// @Param slug path string true \"Slug of the article that you want to favorite\"\n// @Success 200 {object} singleArticleResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /articles/{slug}/favorite [post]\nfunc (h *Handler) Retweet(c echo.Context) error {\n\tid := c.Param(\"id\")\n\tt, err := h.tweetStore.GetTweetById(&id)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif t == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tu, err := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tfor _, o := range *t.Retweets {\n\t\tif u.Username == o.Username {\n\t\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"already retweeted\")))\n\t\t}\n\t}\n\n\tif err := h.tweetStore.Retweet(t, u); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\n\terr = h.userStore.AddTweet(u, t)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\n\te := h.CreateRetweetEvent(u, t)\n\terr = h.userStore.AddLog(u, e)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\ttarget, err := h.userStore.GetByUsername(t.Owner.Username)\n\tif target == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\terr = h.userStore.AddNotification(target, e)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\n\treturn c.JSON(http.StatusOK, newTweetResponse(c, t))\n}\n\n// Favorite godoc\n// @Summary Favorite an article\n// @Description Favorite an article. Auth is required\n// @ID favorite\n// @Tags favorite\n// @Accept  json\n// @Produce  json\n// @Param slug path string true \"Slug of the article that you want to favorite\"\n// @Success 200 {object} singleArticleResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /articles/{slug}/favorite [post]\nfunc (h *Handler) UnRetweet(c echo.Context) error {\n\tid := c.Param(\"id\")\n\tt, err := h.tweetStore.GetTweetById(&id)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif t == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tu, err := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tb := false\n\tfor _, o := range *t.Retweets {\n\t\tif u.Username == o.Username {\n\t\t\tb = true\n\t\t}\n\t}\n\tif !b {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"hasn't retweeted\")))\n\t}\n\n\tif err := h.tweetStore.UnRetweet(t, u); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\n\terr = h.userStore.RemoveTweet(u, &id)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\n\treturn c.JSON(http.StatusOK, newTweetResponse(c, t))\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- handler/tweet.go	(revision f5b85206b39c140fd7a98952034ffa683e55c513)
+++ handler/tweet.go	(date 1611789308321)
@@ -63,8 +63,8 @@
 	if err != nil {
 		return c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))
 	}
-	t.Owner.Username = u.Username
-	t.Owner.ProfilePicture = u.ProfilePicture
+	t.Owner.Username = &u.Username
+	t.Owner.ProfilePicture = &u.ProfilePicture
 	t.Time = time.Now()
 	t.Date = time.Now().Format("2006-01-02")
 
@@ -159,14 +159,14 @@
 		return c.JSON(http.StatusNotFound, utils.NotFound())
 	}
 
-	u, err := h.userStore.GetByUsername(t.Owner.Username)
+	u, err := h.userStore.GetByUsername(*t.Owner.Username)
 	if err != nil {
 		return c.JSON(http.StatusInternalServerError, utils.NewError(err))
 	}
 	if u == nil {
 		return c.JSON(http.StatusNotFound, utils.NotFound())
 	}
-	if u.Username != t.Owner.Username {
+	if u.Username != *t.Owner.Username {
 		return c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New("you can only delete you tweets")))
 	}
 
@@ -266,7 +266,7 @@
 		return c.JSON(http.StatusNotFound, utils.NotFound())
 	}
 	for _, o := range *t.Likes {
-		if u.Username == o.Username {
+		if u.Username == *o.Username {
 			return c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New("already liked")))
 		}
 	}
@@ -280,7 +280,7 @@
 	if err != nil {
 		return c.JSON(http.StatusInternalServerError, utils.NewError(err))
 	}
-	target, err := h.userStore.GetByUsername(t.Owner.Username)
+	target, err := h.userStore.GetByUsername(*t.Owner.Username)
 	if target == nil {
 		return c.JSON(http.StatusNotFound, utils.NotFound())
 	}
@@ -323,7 +323,7 @@
 	}
 	b := false
 	for _, o := range *t.Likes {
-		if u.Username == o.Username {
+		if u.Username == *o.Username {
 			b = true
 		}
 	}
@@ -368,7 +368,7 @@
 		return c.JSON(http.StatusNotFound, utils.NotFound())
 	}
 	for _, o := range *t.Retweets {
-		if u.Username == o.Username {
+		if u.Username == *o.Username {
 			return c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New("already retweeted")))
 		}
 	}
@@ -387,7 +387,7 @@
 	if err != nil {
 		return c.JSON(http.StatusInternalServerError, utils.NewError(err))
 	}
-	target, err := h.userStore.GetByUsername(t.Owner.Username)
+	target, err := h.userStore.GetByUsername(*t.Owner.Username)
 	if target == nil {
 		return c.JSON(http.StatusNotFound, utils.NotFound())
 	}
@@ -430,7 +430,7 @@
 	}
 	b := false
 	for _, o := range *t.Retweets {
-		if u.Username == o.Username {
+		if u.Username == *o.Username {
 			b = true
 		}
 	}
Index: handler/user.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package handler\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/arman-aminian/twitter-backend/model\"\n\t\"github.com/arman-aminian/twitter-backend/utils\"\n\t\"github.com/labstack/echo/v4\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"sort\"\n\t\"strconv\"\n\t\"time\"\n)\n\n// signUp godoc\n// @Summary Register a new user\n// @Description Register a new user\n// @ID sign-up\n// @Tags user\n// @Accept  json\n// @Produce  json\n// @Param user body userRegisterRequest true \"User info for registration\"\n// @Success 201 {object} userResponse\n// @Failure 400 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Router /users [post]\nfunc (h *Handler) SignUp(c echo.Context) error {\n\tu := model.NewUser()\n\treq := &userRegisterRequest{}\n\tif err := req.bind(c, u); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\tif err := h.userStore.Create(u); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\tresponse := newUserResponse(u)\n\tcookie := new(http.Cookie)\n\tcookie.Name = \"Token\"\n\tcookie.Value = response.User.Token\n\tcookie.Expires = time.Now().Add(24 * time.Hour)\n\tc.SetCookie(cookie)\n\t//header('Access-Control-Allow-Origin', yourExactHostname);\n\n\t//c.Response().Header().Set(echo.HeaderAccessControlAllowOrigin, \"http://localhost:3000\")\n\t//c.Response().Header().Add(echo.HeaderAccessControlAllowCredentials, \"true\")\n\t//c.Response().Header().Add(echo.HeaderAccessControlAllowOrigin, \"http://localhost:3000\")\n\t//c.Response().Header().Add(echo.HeaderAccessControlAllowHeaders, \"Origin, X-Requested-With, Content-Type, Accept\")\n\t//c.Response().Header().\n\treturn c.JSON(http.StatusCreated, response)\n}\n\n// Login godoc\n// @Summary Login for existing user\n// @Description Login for existing user\n// @ID login\n// @Tags user\n// @Accept  json\n// @Produce  json\n// @Param user body userLoginRequest true \"Credentials to use\"\n// @Success 200 {object} userResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Router /users/login [post]\nfunc (h *Handler) Login(c echo.Context) error {\n\treq := &userLoginRequest{}\n\tif err := req.bind(c); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\tu, err := h.userStore.GetByEmail(req.User.Email)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusForbidden, utils.AccessForbidden())\n\t}\n\tif !u.CheckPassword(req.User.Password) {\n\t\treturn c.JSON(http.StatusForbidden, utils.AccessForbidden())\n\t}\n\tresponse := newUserResponse(u)\n\t//cookie := new(http.Cookie)\n\t//cookie.Name = \"Token\"\n\t//cookie.Value = response.User.Token\n\t//cookie.Expires = time.Now().Add(24 * time.Hour)\n\t//c.SetCookie(cookie)\n\treturn c.JSON(http.StatusCreated, response)\n}\n\n// UpdateUser godoc\n// @Summary Update current user\n// @Description Update user information for current user\n// @ID update-user\n// @Tags user\n// @Accept  json\n// @Produce  json\n// @Param user body userUpdateRequest true \"User details to update. At least **one** field is required.\"\n// @Success 200 {object} userResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /user [put]\nfunc (h *Handler) UpdateUser(c echo.Context) error {\n\toldUser, err := h.userStore.GetByUsername(c.Param(\"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif oldUser == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tnewUser := model.NewUser()\n\n\tnewUser.Username = oldUser.Username\n\tnewUser.Tweets = oldUser.Tweets\n\tnewUser.Followings = oldUser.Followings\n\tnewUser.Followers = oldUser.Followers\n\tnewUser.Bio = oldUser.Bio\n\tnewUser.Name = oldUser.Name\n\tnewUser.ProfilePicture = oldUser.ProfilePicture\n\tnewUser.HeaderPicture = oldUser.HeaderPicture\n\tnewUser.Password = oldUser.Password\n\tnewUser.Email = oldUser.Email\n\tnewUser.Logs = oldUser.Logs\n\tnewUser.Notifications = oldUser.Notifications\n\n\t//_ = copier.Copy(&newUser, &oldUser)\n\treq := newUserUpdateRequest()\n\treq.populate(newUser)\n\tif err := req.bind(c, newUser); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\tif err := h.userStore.Update(oldUser, newUser); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\treturn c.JSON(http.StatusOK, newUserResponse(newUser))\n}\n\n// GetProfile godoc\n// @Summary Get a profile\n// @Description Get a profile of a user of the system. Auth is optional\n// @ID get-profile\n// @Tags profile\n// @Accept  json\n// @Produce  json\n// @Param username path string true \"Username of the profile to get\"\n// @Success 200 {object} userResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /profiles/{username} [get]\nfunc (h *Handler) GetProfile(c echo.Context) error {\n\tdestUsername := c.Param(\"username\")\n\tfmt.Println(destUsername)\n\tu, err := h.userStore.GetByUsername(destUsername)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\treturn c.JSON(http.StatusOK, newProfileResponse(h.userStore, stringFieldFromToken(c, \"username\"), u))\n}\n\n// UpdateProfile godoc\n// @Summary Update a user's profile\n// @Description Update user profile\n// @ID update-profile\n// @Tags user\n// @Accept  json\n// @Produce  json\n// @Param user body userProfileUpdateRequest true \"User details to update. At least **one** field is required.\"\n// @Success 200 {object} userResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /user [put]\nfunc (h *Handler) UpdateProfile(c echo.Context) error {\n\tu, err := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\treq := newUserProfileUpdateRequest()\n\treq.populate(u)\n\tu.Name = c.FormValue(\"name\")\n\tu.Bio = c.FormValue(\"bio\")\n\tppf, err := c.FormFile(\"profile_picture\")\n\tif err == nil {\n\t\tsrc, err := ppf.Open()\n\t\tif err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tdefer src.Close()\n\n\t\tmediaFolderName := \"media/profile-pictures/\"\n\t\tmediaPath := mediaFolderName + ppf.Filename\n\t\tdst, err := os.Create(mediaPath)\n\t\tif err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tdefer dst.Close()\n\n\t\tif _, err = io.Copy(dst, src); err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tu.ProfilePicture = mediaPath\n\t} else {\n\t\t// Update without Profile Picture\n\t\tu.ProfilePicture = \"\"\n\t}\n\n\thpf, err := c.FormFile(\"header_picture\")\n\tif err == nil {\n\t\tsrc, err := hpf.Open()\n\t\tif err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tdefer src.Close()\n\n\t\tmediaFolderName := \"media/header-pictures/\"\n\t\tmediaPath := mediaFolderName + hpf.Filename\n\t\tdst, err := os.Create(mediaPath)\n\t\tif err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tdefer dst.Close()\n\n\t\tif _, err = io.Copy(dst, src); err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tu.HeaderPicture = mediaPath\n\t} else {\n\t\t// Update without Header Picture\n\t\tu.HeaderPicture = \"\"\n\t}\n\n\tif err := h.userStore.UpdateProfile(u); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\tfmt.Println(u.Name)\n\treturn c.JSON(http.StatusOK, newProfileResponse(h.userStore, u.Username, u))\n}\n\nfunc (h *Handler) GetProfilePictureFile(c echo.Context) error {\n\tmediaFolderName := \"media/profile-pictures/\"\n\tmediaPath := mediaFolderName + c.Param(\"filename\")\n\treturn c.File(mediaPath)\n}\n\nfunc (h *Handler) GetHeaderPictureFile(c echo.Context) error {\n\tmediaFolderName := \"media/header-pictures/\"\n\tmediaPath := mediaFolderName + c.Param(\"filename\")\n\treturn c.File(mediaPath)\n}\n\n// Follow godoc\n// @Summary Follow a user\n// @Description Follow a user by username\n// @ID follow\n// @Tags follow\n// @Accept  json\n// @Produce  json\n// @Param username path string true \"Username of the profile you want to follow\"\n// @Success 200 {object} profileResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /profiles/{username}/follow [post]\nfunc (h *Handler) Follow(c echo.Context) error {\n\tfollower, err := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tu, err := h.userStore.GetByUsername(c.Param(\"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tif u.Username == follower.Username {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"can't follow yourself\")))\n\t}\n\tif Contains(*u.Followers, follower.Username) || Contains(*follower.Followings, u.Username) {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"already follows the target\")))\n\t}\n\n\tif err := h.userStore.AddFollower(u, follower); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\n\te := h.CreateFollowEvent(follower, u)\n\terr = h.userStore.AddLog(follower, e)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\terr = h.userStore.AddNotification(u, e)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\n\treturn c.JSON(http.StatusOK, newProfileResponse(h.userStore, follower.Username, u))\n}\n\n// Unfollow godoc\n// @Summary Unfollow a user\n// @Description Unfollow a user by username\n// @ID unfollow\n// @Tags follow\n// @Accept  json\n// @Produce  json\n// @Param username path string true \"Username of the profile you want to unfollow\"\n// @Success 201 {object} userResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /profiles/{username}/follow [delete]\nfunc (h *Handler) UnFollow(c echo.Context) error {\n\tfollower, err := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tu, err := h.userStore.GetByUsername(c.Param(\"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tif u.Username == follower.Username {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"can't unfollow yourself\")))\n\t}\n\tif !Contains(*u.Followers, follower.Username) || !Contains(*follower.Followings, u.Username) {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"doesn't follow the target\")))\n\t}\n\tif err := h.userStore.RemoveFollower(u, follower); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\treturn c.JSON(http.StatusOK, newProfileResponse(h.userStore, stringFieldFromToken(c, \"username\"), u))\n}\n\n// Articles godoc\n// @Summary Get recent articles globally\n// @Description Get most recent articles globally. Use query parameters to filter results. Auth is optional\n// @ID get-articles\n// @Tags article\n// @Accept  json\n// @Produce  json\n// @Param tag query string false \"Filter by tag\"\n// @Param author query string false \"Filter by author (username)\"\n// @Param favorited query string false \"Filter by favorites of a user (username)\"\n// @Param limit query integer false \"Limit number of articles returned (default is 20)\"\n// @Param offset query integer false \"Offset/skip number of articles (default is 0)\"\n// @Success 200 {object} articleListResponse\n// @Failure 500 {object} utils.Error\n// @Router /articles [get]\nfunc (h *Handler) GetTimeline(c echo.Context) error {\n\tday, err := strconv.Atoi(c.Param(\"day\"))\n\tif err != nil {\n\t\tday = 0\n\t}\n\tday = -1 * day\n\tu, err := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\n\tvar usernames []string\n\tfor _, f := range *u.Followings {\n\t\tusernames = append(usernames, f.Username)\n\t}\n\tusernames = append(usernames, u.Username)\n\tif len(usernames) == 0 {\n\t\treturn c.JSON(http.StatusOK, newTweetListResponse(c, stringFieldFromToken(c, \"username\"), nil, 0))\n\t}\n\n\ttweetsId, err := h.userStore.GetTweetIdListFromUsernameList(usernames)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\tif len(*tweetsId) == 0 {\n\t\treturn c.JSON(http.StatusOK, newTweetListResponse(c, stringFieldFromToken(c, \"username\"), nil, 0))\n\t}\n\n\ttimelineTweets, err := h.tweetStore.GetTimelineFromTweetIDs(*tweetsId, day)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\n\t// sort timeline by tweet's creating time\n\ttimeline := *timelineTweets\n\tsort.Slice(timeline, func(i, j int) bool {\n\t\treturn timeline[i].Time.After(timeline[j].Time)\n\t})\n\treturn c.JSON(http.StatusOK, newTweetListResponse(c, stringFieldFromToken(c, \"username\"), &timeline, len(timeline)))\n}\n\nfunc (h *Handler) SearchUsernames(c echo.Context) error {\n\tquery := c.QueryParam(\"query\")\n\tif query == \"\" {\n\t\treturn c.JSON(http.StatusBadRequest, utils.NewError(errors.New(\"nothing to search for\")))\n\t}\n\n\tresult, err := h.userStore.GetUsernameSearchResult(query)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn c.JSON(http.StatusOK, newOwnerList(result))\n}\n\nfunc (h *Handler) SearchTweets(c echo.Context) error {\n\tquery := &model.SearchQuery{}\n\terr := c.Bind(query)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\tif query.Query == \"\" {\n\t\treturn c.JSON(http.StatusBadRequest, utils.NewError(errors.New(\"nothing to search for\")))\n\t}\n\tresult, err := h.tweetStore.GetTweetSearchResult(query.Query)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\treturn c.JSON(http.StatusOK, newTweetListResponse(c, stringFieldFromToken(c, \"username\"), result, len(*result)))\n}\n\nfunc (h *Handler) GetFollowingAndFollowersList(c echo.Context) error {\n\tu, err := h.userStore.GetByUsername(c.Param(\"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\treturn c.JSON(http.StatusOK, newFollowingAndFollowersList(h.userStore, stringFieldFromToken(c, \"username\"), u))\n}\n\nfunc (h *Handler) GetLogs(c echo.Context) error {\n\tu, err := h.userStore.GetByUsername(c.Param(\"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tif u.Username != stringFieldFromToken(c, \"username\") {\n\t\treturn c.JSON(http.StatusBadRequest, errors.New(\"can't get another user's logs\"))\n\t}\n\treturn c.JSON(http.StatusOK, newLogsList(u))\n}\n\nfunc (h *Handler) GetNotifications(c echo.Context) error {\n\tu, err := h.userStore.GetByUsername(c.Param(\"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\treturn c.JSON(http.StatusOK, newNotificationsList(u))\n}\n\nfunc (h *Handler) GetSuggestions(c echo.Context) error {\n\tusername := stringFieldFromToken(c, \"username\")\n\tu, err := h.userStore.GetByUsername(username)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tif len(*u.Followings) == 0 {\n\t\treturn c.JSON(http.StatusOK, newOwnerList(nil))\n\t}\n\tvar suggestions []model.Owner\n\tfollowings := *u.Followings\n\tfor _, f := range followings {\n\t\tfollowing, _ := h.userStore.GetByUsername(f.Username)\n\t\tsuggestions = append(suggestions, *following.Followings...)\n\t}\n\n\tfor i := range suggestions {\n\t\tfor j := range followings {\n\t\t\tif suggestions[i] == followings[j] {\n\t\t\t\tsuggestions = removeIndex(suggestions, i)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// to sort suggestions by their frequencies\n\tsuggestionsFreq := dupCount(suggestions)\n\tsorted := make([]model.Owner, 0, len(suggestionsFreq))\n\tfor name := range suggestionsFreq {\n\t\tsorted = append(sorted, name)\n\t}\n\tsort.Slice(sorted, func(i, j int) bool {\n\t\treturn suggestionsFreq[sorted[i]] > suggestionsFreq[sorted[j]]\n\t})\n\n\tmaxNumberOfSuggestions := 3\n\tif len(sorted) < maxNumberOfSuggestions {\n\t\treturn c.JSON(http.StatusOK, newOwnerList(&sorted))\n\t}\n\tsorted = sorted[:maxNumberOfSuggestions]\n\treturn c.JSON(http.StatusOK, newOwnerList(&sorted))\n}\n\nfunc removeIndex(s []model.Owner, index int) []model.Owner {\n\treturn append(s[:index], s[index+1:]...)\n}\n\nfunc dupCount(list []model.Owner) map[model.Owner]int {\n\tduplicateFrequency := make(map[model.Owner]int)\n\tfor _, item := range list {\n\t\t_, exist := duplicateFrequency[item]\n\t\tif exist {\n\t\t\tduplicateFrequency[item] += 1 // increase counter by 1 if already in the map\n\t\t} else {\n\t\t\tduplicateFrequency[item] = 1 // else start counting from 1\n\t\t}\n\t}\n\treturn duplicateFrequency\n}\n\nfunc getFollowingUsernames(followings []model.Owner) []string {\n\tvar res []string\n\tfor _, f := range followings {\n\t\tres = append(res, f.Username)\n\t}\n\treturn res\n}\n\nfunc stringFieldFromToken(c echo.Context, field string) string {\n\tfield, ok := c.Get(field).(string)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn field\n}\n\nfunc Contains(slice []model.Owner, val string) bool {\n\tfor _, item := range slice {\n\t\tif item.Username == val {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- handler/user.go	(revision f5b85206b39c140fd7a98952034ffa683e55c513)
+++ handler/user.go	(date 1611789308345)
@@ -388,7 +388,7 @@
 
 	var usernames []string
 	for _, f := range *u.Followings {
-		usernames = append(usernames, f.Username)
+		usernames = append(usernames, *f.Username)
 	}
 	usernames = append(usernames, u.Username)
 	if len(usernames) == 0 {
@@ -472,12 +472,16 @@
 
 func (h *Handler) GetNotifications(c echo.Context) error {
 	u, err := h.userStore.GetByUsername(c.Param("username"))
+	fmt.Println(stringFieldFromToken(c, "username"))
 	if err != nil {
 		return c.JSON(http.StatusInternalServerError, utils.NewError(err))
 	}
 	if u == nil {
 		return c.JSON(http.StatusNotFound, utils.NotFound())
 	}
+	if u.Username != stringFieldFromToken(c, "username") {
+		return c.JSON(http.StatusUnprocessableEntity, errors.New("can't get another user's notifications"))
+	}
 	return c.JSON(http.StatusOK, newNotificationsList(u))
 }
 
@@ -496,7 +500,7 @@
 	var suggestions []model.Owner
 	followings := *u.Followings
 	for _, f := range followings {
-		following, _ := h.userStore.GetByUsername(f.Username)
+		following, _ := h.userStore.GetByUsername(*f.Username)
 		suggestions = append(suggestions, *following.Followings...)
 	}
 
@@ -547,7 +551,7 @@
 func getFollowingUsernames(followings []model.Owner) []string {
 	var res []string
 	for _, f := range followings {
-		res = append(res, f.Username)
+		res = append(res, *f.Username)
 	}
 	return res
 }
@@ -562,7 +566,7 @@
 
 func Contains(slice []model.Owner, val string) bool {
 	for _, item := range slice {
-		if item.Username == val {
+		if *item.Username == val {
 			return true
 		}
 	}
Index: model/owner.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package model\n\ntype Owner struct {\n\tUsername       string `json:\"username\"`\n\tProfilePicture string `json:\"profile_picture\"`\n\tName           string `json:\"name\"`\n\tBio            string `json:\"bio\"`\n}\n\nfunc NewOwner(username string, pic string, name string, bio string) *Owner {\n\treturn &Owner{\n\t\tUsername:       username,\n\t\tProfilePicture: pic,\n\t\tName:           name,\n\t\tBio:            bio,\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- model/owner.go	(revision f5b85206b39c140fd7a98952034ffa683e55c513)
+++ model/owner.go	(date 1611788524348)
@@ -1,13 +1,13 @@
 package model
 
 type Owner struct {
-	Username       string `json:"username"`
-	ProfilePicture string `json:"profile_picture"`
-	Name           string `json:"name"`
-	Bio            string `json:"bio"`
+	Username       *string `json:"username"`
+	ProfilePicture *string `json:"profile_picture"`
+	Name           *string `json:"name"`
+	Bio            *string `json:"bio"`
 }
 
-func NewOwner(username string, pic string, name string, bio string) *Owner {
+func NewOwner(username *string, pic *string, name *string, bio *string) *Owner {
 	return &Owner{
 		Username:       username,
 		ProfilePicture: pic,
Index: handler/event.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package handler\n\nimport (\n\t\"fmt\"\n\t\"github.com/arman-aminian/twitter-backend/model\"\n)\n\nfunc (h *Handler) CreateFollowEvent(src *model.User, target *model.User) *model.Event {\n\te := model.NewEvent()\n\te.Mode = \"Follow\"\n\te.Source = *model.NewOwner(src.Username, src.ProfilePicture, src.Name, src.Bio)\n\te.Target = *model.NewOwner(target.Username, target.ProfilePicture, target.Name, target.Bio)\n\te.Content = fmt.Sprintf(\"User %s followed User %s at %s.\", e.Source.Username, e.Target.Username, e.TimeStamp)\n\treturn e\n}\n\nfunc (h *Handler) CreateLikeEvent(src *model.User, t *model.Tweet) *model.Event {\n\te := model.NewEvent()\n\te.Mode = \"Like\"\n\te.Source = *model.NewOwner(src.Username, src.ProfilePicture, src.Name, src.Bio)\n\te.Target = *model.NewOwner(t.Owner.Username, t.Owner.ProfilePicture, t.Owner.Name, t.Owner.Bio)\n\te.Content = fmt.Sprintf(\"User %s liked Tweet %s at %s.\", e.Source.Username, t.Text, e.TimeStamp)\n\treturn e\n}\n\nfunc (h *Handler) CreateRetweetEvent(src *model.User, t *model.Tweet) *model.Event {\n\te := model.NewEvent()\n\te.Mode = \"Retweet\"\n\te.Source = *model.NewOwner(src.Username, src.ProfilePicture, src.Name, src.Bio)\n\te.Target = *model.NewOwner(t.Owner.Username, t.Owner.ProfilePicture, t.Owner.Name, t.Owner.Bio)\n\te.Content = fmt.Sprintf(\"User %s retweeted Tweet %s at %s.\", e.Source.Username, t.Text, e.TimeStamp)\n\treturn e\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- handler/event.go	(revision f5b85206b39c140fd7a98952034ffa683e55c513)
+++ handler/event.go	(date 1611789547453)
@@ -8,26 +8,26 @@
 func (h *Handler) CreateFollowEvent(src *model.User, target *model.User) *model.Event {
 	e := model.NewEvent()
 	e.Mode = "Follow"
-	e.Source = *model.NewOwner(src.Username, src.ProfilePicture, src.Name, src.Bio)
-	e.Target = *model.NewOwner(target.Username, target.ProfilePicture, target.Name, target.Bio)
-	e.Content = fmt.Sprintf("User %s followed User %s at %s.", e.Source.Username, e.Target.Username, e.TimeStamp)
+	e.Source = *model.NewOwner(&src.Username, &src.ProfilePicture, &src.Name, &src.Bio)
+	e.Target = *model.NewOwner(&target.Username, &target.ProfilePicture, &target.Name, &target.Bio)
+	e.Content = fmt.Sprintf("User %s followed User %s at %s.", *e.Source.Username, *e.Target.Username, e.TimeStamp)
 	return e
 }
 
 func (h *Handler) CreateLikeEvent(src *model.User, t *model.Tweet) *model.Event {
 	e := model.NewEvent()
 	e.Mode = "Like"
-	e.Source = *model.NewOwner(src.Username, src.ProfilePicture, src.Name, src.Bio)
+	e.Source = *model.NewOwner(&src.Username, &src.ProfilePicture, &src.Name, &src.Bio)
 	e.Target = *model.NewOwner(t.Owner.Username, t.Owner.ProfilePicture, t.Owner.Name, t.Owner.Bio)
-	e.Content = fmt.Sprintf("User %s liked Tweet %s at %s.", e.Source.Username, t.Text, e.TimeStamp)
+	e.Content = fmt.Sprintf("User %s liked Tweet %s at %s.", *e.Source.Username, t.Text, e.TimeStamp)
 	return e
 }
 
 func (h *Handler) CreateRetweetEvent(src *model.User, t *model.Tweet) *model.Event {
 	e := model.NewEvent()
 	e.Mode = "Retweet"
-	e.Source = *model.NewOwner(src.Username, src.ProfilePicture, src.Name, src.Bio)
+	e.Source = *model.NewOwner(&src.Username, &src.ProfilePicture, &src.Name, &src.Bio)
 	e.Target = *model.NewOwner(t.Owner.Username, t.Owner.ProfilePicture, t.Owner.Name, t.Owner.Bio)
-	e.Content = fmt.Sprintf("User %s retweeted Tweet %s at %s.", e.Source.Username, t.Text, e.TimeStamp)
+	e.Content = fmt.Sprintf("User %s retweeted Tweet %s at %s.", *e.Source.Username, t.Text, e.TimeStamp)
 	return e
 }
