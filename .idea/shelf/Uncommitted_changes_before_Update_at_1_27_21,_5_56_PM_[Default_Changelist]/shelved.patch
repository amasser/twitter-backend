Index: handler/user.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package handler\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/arman-aminian/twitter-backend/model\"\n\t\"github.com/arman-aminian/twitter-backend/utils\"\n\t\"github.com/jinzhu/copier\"\n\t\"github.com/labstack/echo/v4\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"sort\"\n\t\"strconv\"\n\t\"time\"\n)\n\n// signUp godoc\n// @Summary Register a new user\n// @Description Register a new user\n// @ID sign-up\n// @Tags user\n// @Accept  json\n// @Produce  json\n// @Param user body userRegisterRequest true \"User info for registration\"\n// @Success 201 {object} userResponse\n// @Failure 400 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Router /users [post]\nfunc (h *Handler) SignUp(c echo.Context) error {\n\tu := model.NewUser()\n\treq := &userRegisterRequest{}\n\tif err := req.bind(c, u); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\tif err := h.userStore.Create(u); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\tresponse := newUserResponse(u)\n\tcookie := new(http.Cookie)\n\tcookie.Name = \"Token\"\n\tcookie.Value = response.User.Token\n\tcookie.Expires = time.Now().Add(24 * time.Hour)\n\tc.SetCookie(cookie)\n\t//header('Access-Control-Allow-Origin', yourExactHostname);\n\n\t//c.Response().Header().Set(echo.HeaderAccessControlAllowOrigin, \"http://localhost:3000\")\n\t//c.Response().Header().Add(echo.HeaderAccessControlAllowCredentials, \"true\")\n\t//c.Response().Header().Add(echo.HeaderAccessControlAllowOrigin, \"http://localhost:3000\")\n\t//c.Response().Header().Add(echo.HeaderAccessControlAllowHeaders, \"Origin, X-Requested-With, Content-Type, Accept\")\n\t//c.Response().Header().\n\treturn c.JSON(http.StatusCreated, response)\n}\n\n// Login godoc\n// @Summary Login for existing user\n// @Description Login for existing user\n// @ID login\n// @Tags user\n// @Accept  json\n// @Produce  json\n// @Param user body userLoginRequest true \"Credentials to use\"\n// @Success 200 {object} userResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Router /users/login [post]\nfunc (h *Handler) Login(c echo.Context) error {\n\treq := &userLoginRequest{}\n\tif err := req.bind(c); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\tu, err := h.userStore.GetByEmail(req.User.Email)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusForbidden, utils.AccessForbidden())\n\t}\n\tif !u.CheckPassword(req.User.Password) {\n\t\treturn c.JSON(http.StatusForbidden, utils.AccessForbidden())\n\t}\n\tresponse := newUserResponse(u)\n\t//cookie := new(http.Cookie)\n\t//cookie.Name = \"Token\"\n\t//cookie.Value = response.User.Token\n\t//cookie.Expires = time.Now().Add(24 * time.Hour)\n\t//c.SetCookie(cookie)\n\treturn c.JSON(http.StatusCreated, response)\n}\n\n// UpdateUser godoc\n// @Summary Update current user\n// @Description Update user information for current user\n// @ID update-user\n// @Tags user\n// @Accept  json\n// @Produce  json\n// @Param user body userUpdateRequest true \"User details to update. At least **one** field is required.\"\n// @Success 200 {object} userResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /user [put]\nfunc (h *Handler) UpdateUser(c echo.Context) error {\n\toldUser, err := h.userStore.GetByUsername(c.Param(\"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif oldUser == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tnewUser := model.NewUser()\n\t_ = copier.Copy(&newUser, &oldUser)\n\treq := newUserUpdateRequest()\n\treq.populate(newUser)\n\tif err := req.bind(c, newUser); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\tif err := h.userStore.Update(oldUser, newUser); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\treturn c.JSON(http.StatusOK, newUserResponse(newUser))\n}\n\n// GetProfile godoc\n// @Summary Get a profile\n// @Description Get a profile of a user of the system. Auth is optional\n// @ID get-profile\n// @Tags profile\n// @Accept  json\n// @Produce  json\n// @Param username path string true \"Username of the profile to get\"\n// @Success 200 {object} userResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /profiles/{username} [get]\nfunc (h *Handler) GetProfile(c echo.Context) error {\n\tdestUsername := c.Param(\"username\")\n\tfmt.Println(destUsername)\n\tu, err := h.userStore.GetByUsername(destUsername)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\treturn c.JSON(http.StatusOK, newProfileResponse(h.userStore, stringFieldFromToken(c, \"username\"), u))\n}\n\n// UpdateProfile godoc\n// @Summary Update a user's profile\n// @Description Update user profile\n// @ID update-profile\n// @Tags user\n// @Accept  json\n// @Produce  json\n// @Param user body userProfileUpdateRequest true \"User details to update. At least **one** field is required.\"\n// @Success 200 {object} userResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /user [put]\nfunc (h *Handler) UpdateProfile(c echo.Context) error {\n\tu, err := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\treq := newUserProfileUpdateRequest()\n\treq.populate(u)\n\tu.Name = c.FormValue(\"name\")\n\tu.Bio = c.FormValue(\"bio\")\n\tppf, err := c.FormFile(\"profile_picture\")\n\tif err == nil {\n\t\tsrc, err := ppf.Open()\n\t\tif err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tdefer src.Close()\n\n\t\tmediaFolderName := \"media/profile-pictures/\"\n\t\tmediaPath := mediaFolderName + ppf.Filename\n\t\tdst, err := os.Create(mediaPath)\n\t\tif err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tdefer dst.Close()\n\n\t\tif _, err = io.Copy(dst, src); err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tu.ProfilePicture = mediaPath\n\t} else {\n\t\t// Update without Profile Picture\n\t\tu.ProfilePicture = \"\"\n\t}\n\n\thpf, err := c.FormFile(\"header_picture\")\n\tif err == nil {\n\t\tsrc, err := hpf.Open()\n\t\tif err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tdefer src.Close()\n\n\t\tmediaFolderName := \"media/header-pictures/\"\n\t\tmediaPath := mediaFolderName + hpf.Filename\n\t\tdst, err := os.Create(mediaPath)\n\t\tif err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tdefer dst.Close()\n\n\t\tif _, err = io.Copy(dst, src); err != nil {\n\t\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t\t}\n\t\tu.HeaderPicture = mediaPath\n\t} else {\n\t\t// Update without Header Picture\n\t\tu.HeaderPicture = \"\"\n\t}\n\n\tif err := h.userStore.UpdateProfile(u); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\treturn c.JSON(http.StatusOK, newProfileResponse(h.userStore, u.Username, u))\n}\n\nfunc (h *Handler) GetProfilePictureFile(c echo.Context) error {\n\tmediaFolderName := \"media/profile-pictures/\"\n\tmediaPath := mediaFolderName + c.Param(\"filename\")\n\treturn c.File(mediaPath)\n}\n\nfunc (h *Handler) GetHeaderPictureFile(c echo.Context) error {\n\tmediaFolderName := \"media/header-pictures/\"\n\tmediaPath := mediaFolderName + c.Param(\"filename\")\n\treturn c.File(mediaPath)\n}\n\n// Follow godoc\n// @Summary Follow a user\n// @Description Follow a user by username\n// @ID follow\n// @Tags follow\n// @Accept  json\n// @Produce  json\n// @Param username path string true \"Username of the profile you want to follow\"\n// @Success 200 {object} profileResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /profiles/{username}/follow [post]\nfunc (h *Handler) Follow(c echo.Context) error {\n\tfollower, err := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tu, err := h.userStore.GetByUsername(c.Param(\"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tif u.Username == follower.Username {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"can't follow yourself\")))\n\t}\n\tif Contains(*u.Followers, follower.Username) || Contains(*follower.Followings, u.Username) {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"already follows the target\")))\n\t}\n\n\tif err := h.userStore.AddFollower(u, follower); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\n\te := h.CreateFollowEvent(follower, u)\n\terr = h.userStore.AddLog(follower, e)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\terr = h.userStore.AddNotification(u, e)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\n\treturn c.JSON(http.StatusOK, newProfileResponse(h.userStore, follower.Username, u))\n}\n\n// Unfollow godoc\n// @Summary Unfollow a user\n// @Description Unfollow a user by username\n// @ID unfollow\n// @Tags follow\n// @Accept  json\n// @Produce  json\n// @Param username path string true \"Username of the profile you want to unfollow\"\n// @Success 201 {object} userResponse\n// @Failure 400 {object} utils.Error\n// @Failure 401 {object} utils.Error\n// @Failure 422 {object} utils.Error\n// @Failure 404 {object} utils.Error\n// @Failure 500 {object} utils.Error\n// @Security ApiKeyAuth\n// @Router /profiles/{username}/follow [delete]\nfunc (h *Handler) UnFollow(c echo.Context) error {\n\tfollower, err := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tu, err := h.userStore.GetByUsername(c.Param(\"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tif u.Username == follower.Username {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"can't unfollow yourself\")))\n\t}\n\tif !Contains(*u.Followers, follower.Username) || !Contains(*follower.Followings, u.Username) {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(errors.New(\"doesn't follow the target\")))\n\t}\n\tif err := h.userStore.RemoveFollower(u, follower); err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\treturn c.JSON(http.StatusOK, newProfileResponse(h.userStore, stringFieldFromToken(c, \"username\"), u))\n}\n\n// Articles godoc\n// @Summary Get recent articles globally\n// @Description Get most recent articles globally. Use query parameters to filter results. Auth is optional\n// @ID get-articles\n// @Tags article\n// @Accept  json\n// @Produce  json\n// @Param tag query string false \"Filter by tag\"\n// @Param author query string false \"Filter by author (username)\"\n// @Param favorited query string false \"Filter by favorites of a user (username)\"\n// @Param limit query integer false \"Limit number of articles returned (default is 20)\"\n// @Param offset query integer false \"Offset/skip number of articles (default is 0)\"\n// @Success 200 {object} articleListResponse\n// @Failure 500 {object} utils.Error\n// @Router /articles [get]\nfunc (h *Handler) GetTimeline(c echo.Context) error {\n\tday, err := strconv.Atoi(c.Param(\"day\"))\n\tif err != nil {\n\t\tday = 0\n\t}\n\tday = -1 * day\n\tu, err := h.userStore.GetByUsername(stringFieldFromToken(c, \"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\n\tvar usernames []string\n\tfor _, f := range *u.Followings {\n\t\tusernames = append(usernames, f.Username)\n\t}\n\tusernames = append(usernames, u.Username)\n\tif len(usernames) == 0 {\n\t\treturn c.JSON(http.StatusOK, newTweetListResponse(c, stringFieldFromToken(c, \"username\"), nil, 0))\n\t}\n\n\ttweetsId, err := h.userStore.GetTweetIdListFromUsernameList(usernames)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\tif len(*tweetsId) == 0 {\n\t\treturn c.JSON(http.StatusOK, newTweetListResponse(c, stringFieldFromToken(c, \"username\"), nil, 0))\n\t}\n\n\ttimelineTweets, err := h.tweetStore.GetTimelineFromTweetIDs(*tweetsId, day)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\n\t// sort timeline by tweet's creating time\n\ttimeline := *timelineTweets\n\tsort.Slice(timeline, func(i, j int) bool {\n\t\treturn timeline[i].Time.After(timeline[j].Time)\n\t})\n\treturn c.JSON(http.StatusOK, newTweetListResponse(c, stringFieldFromToken(c, \"username\"), &timeline, len(timeline)))\n}\n\nfunc (h *Handler) SearchUsernames(c echo.Context) error {\n\tquery := c.QueryParam(\"query\")\n\tif query == \"\" {\n\t\treturn c.JSON(http.StatusBadRequest, utils.NewError(errors.New(\"nothing to search for\")))\n\t}\n\n\tresult, err := h.userStore.GetUsernameSearchResult(query)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn c.JSON(http.StatusOK, newOwnerList(result))\n}\n\nfunc (h *Handler) SearchTweets(c echo.Context) error {\n\tquery := &model.SearchQuery{}\n\terr := c.Bind(query)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\tif query.Query == \"\" {\n\t\treturn c.JSON(http.StatusBadRequest, utils.NewError(errors.New(\"nothing to search for\")))\n\t}\n\tresult, err := h.tweetStore.GetTweetSearchResult(query.Query)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusUnprocessableEntity, utils.NewError(err))\n\t}\n\treturn c.JSON(http.StatusOK, newTweetListResponse(c, stringFieldFromToken(c, \"username\"), result, len(*result)))\n}\n\nfunc (h *Handler) GetFollowingAndFollowersList(c echo.Context) error {\n\tu, err := h.userStore.GetByUsername(c.Param(\"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\treturn c.JSON(http.StatusOK, newFollowingAndFollowersList(h.userStore, stringFieldFromToken(c, \"username\"), u))\n}\n\nfunc (h *Handler) GetLogs(c echo.Context) error {\n\tu, err := h.userStore.GetByUsername(c.Param(\"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\treturn c.JSON(http.StatusOK, newLogsList(u))\n}\n\nfunc (h *Handler) GetNotifications(c echo.Context) error {\n\tu, err := h.userStore.GetByUsername(c.Param(\"username\"))\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\treturn c.JSON(http.StatusOK, newNotificationsList(u))\n}\n\nfunc (h *Handler) GetSuggestions(c echo.Context) error {\n\tusername := stringFieldFromToken(c, \"username\")\n\tu, err := h.userStore.GetByUsername(username)\n\tif err != nil {\n\t\treturn c.JSON(http.StatusInternalServerError, utils.NewError(err))\n\t}\n\tif u == nil {\n\t\treturn c.JSON(http.StatusNotFound, utils.NotFound())\n\t}\n\tif len(*u.Followings) == 0 {\n\t\treturn c.JSON(http.StatusOK, newOwnerList(nil))\n\t}\n\tvar suggestions []model.Owner\n\tfor _, f := range *u.Followings {\n\t\tfollowing, _ := h.userStore.GetByUsername(f.Username)\n\t\tsuggestions = append(suggestions, *following.Followings...)\n\t}\n\n\t// to sort suggestions by their frequencies\n\tsuggestionsFreq := dupCount(suggestions)\n\tsorted := make([]model.Owner, 0, len(suggestionsFreq))\n\tfor name := range suggestionsFreq {\n\t\tsorted = append(sorted, name)\n\t}\n\tsort.Slice(sorted, func(i, j int) bool {\n\t\treturn suggestionsFreq[sorted[i]] > suggestionsFreq[sorted[j]]\n\t})\n\n\tmaxNumberOfSuggestions := 3\n\tif len(sorted) < maxNumberOfSuggestions {\n\t\treturn c.JSON(http.StatusOK, newOwnerList(&sorted))\n\t}\n\tsorted = sorted[:maxNumberOfSuggestions]\n\treturn c.JSON(http.StatusOK, newOwnerList(&sorted))\n}\n\nfunc dupCount(list []model.Owner) map[model.Owner]int {\n\tduplicateFrequency := make(map[model.Owner]int)\n\tfor _, item := range list {\n\t\t_, exist := duplicateFrequency[item]\n\t\tif exist {\n\t\t\tduplicateFrequency[item] += 1 // increase counter by 1 if already in the map\n\t\t} else {\n\t\t\tduplicateFrequency[item] = 1 // else start counting from 1\n\t\t}\n\t}\n\treturn duplicateFrequency\n}\n\nfunc getFollowingUsernames(followings []model.Owner) []string {\n\tvar res []string\n\tfor _, f := range followings {\n\t\tres = append(res, f.Username)\n\t}\n\treturn res\n}\n\nfunc stringFieldFromToken(c echo.Context, field string) string {\n\tfield, ok := c.Get(field).(string)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn field\n}\n\nfunc Contains(slice []model.Owner, val string) bool {\n\tfor _, item := range slice {\n\t\tif item.Username == val {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- handler/user.go	(revision 76a848c07fb07582c1b395651878c131581447d6)
+++ handler/user.go	(date 1611755452875)
@@ -450,6 +450,9 @@
 	if u == nil {
 		return c.JSON(http.StatusNotFound, utils.NotFound())
 	}
+	if u.Username != stringFieldFromToken(c, "username") {
+		return c.JSON(http.StatusBadRequest, errors.New("can't get another user's logs"))
+	}
 	return c.JSON(http.StatusOK, newLogsList(u))
 }
 
